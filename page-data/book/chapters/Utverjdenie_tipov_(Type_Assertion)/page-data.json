{"componentChunkName":"component---src-page-templates-book-page-book-page-provider-tsx","path":"/book/chapters/Utverjdenie_tipov_(Type_Assertion)","result":{"pageContext":{"localization":{"lang":"ru","title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи.","appNavigation":[{"id":"index","path":"/","name":"Главная"},{"id":"book-contents","path":"/book/chapters","name":"Оглавление"},{"id":"what-is-new-contents","path":"/what-is-new","name":"Что нового?"},{"id":"pdf","path":"/pdf","name":"PDF Версия"}],"notification":{"behaviorNotification":{"copyLink":"Ссылка скопирована!"}},"layouts":{"shared":{"informers":{"donateInformer":{"minBanner":{"label":"Хочешь поддержать проект финансово?","buttons":{"yes":"Да, хочу! Узнать подробнее...","no":"Нет. Закрыть окно."}},"maxBanner":{"html":{"__html":"Чтобы <b>контент</b> приносил <b>максимальную пользу</b> его <b>необходимо</b> постоянно <b>совершенствовать</b> и <b>адаптировать</b>\n        под каждую новую версию <i>TypeScript</i>. Это отнимает <b>много времени</b> и без Вашей, даже <b>незначительно\n        финансовой</b>, поддержки практически <b>невозможно</b>. Помогая проекту вы прежде всего принимаете <b>участие</b> в\n        <b>развитии</b> профессионального уровня ваших <b>друзей</b>, <b>коллег</b>, <b>подчиненных</b>. Выпусти желание\n        сделать свой мир лучше. <b>Сделай контент для будующих специалистов ещё качественей и доступней!</b>"},"href":"#"}},"watchWithTelegramInformer":{"text":["Хочешь поддерживать свои знания в актуальном состоянии?","Тогда подписывайся на Telegram канал и узнавай обо всех изменениях!"],"subscribeButton":{"label":"Подписаться"}},"contentLevelUpInformer":{"text":"Кажется непонятным и слишком сложным? Чего-то не хватает? Расскажи об этом! Помоги сделать контент более доступным для следующих поколений!","buttons":[{"label":"Сообщить на Github","href":""}]}},"links":{"telegram":"#"},"appContent":{"contentNav":{"prevButton":{"label":"Назад"},"nextButton":{"label":"Вперед"}}},"appHeader":{"navToggleButton":{"tooltips":{"open":["Открыть боковое","меню"],"close":["Закрыть боковое","меню"]}},"appMenu":{"pdfButton":{"href":"#","tooltip":["Скачать","PDF версию"],"label":"Скачать PDF версию"},"telegramButton":{"href":"https://t.me/nauchikus","tooltip":["Следить за","изменениями в","Telegram"],"label":"Следить за изменениями в Telegram"},"githubButton":{"href":"https://github.com/nauchikus/typescript-definitive-guide","tooltip":["Посетить проект на","Github"],"label":"Посетить проект на Github"}},"donateDropdown":{"href":"https://yasobe.ru/na/typescript_definitive_guide","toggleButton":{"label":["Поддержать","финансово"]},"content":{"title":"Сделай контент для будующих поколений ещё качественей и доступней!","subtitle":{"__html":"Контент требует постоянного совершенстования и адаптации под каждую новую версию\nязыка TypeScript.\nЭто отнимает много времени и без Вашей, даже незначительно финансовой, поддержки практически\nневозможно.\nПрийми участие в развитии профессионального уровня своих друзей, коллег, подчиненных. Встань на\nсторону небезразличных!"}}},"appSearch":{"inputPlaceholder":"Я ищу...","submitButton":{"ariaLabel":"Отправить"}}},"pdf":{"downloadPdfBookButton":{"title":"Скачать PDF Версию","href":"pdf/TypeScript Подробное Руководство.pdf"}}}},"pages":{"index":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"appDescription":"Книга и документация в одном","subtitleAll":["TypeScript в деталях","TypeScript крупным планом","TypeScript под микроскопом","TypeScript со всех сторон"]}},"book__chapters":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"},"collapseTocButton":{"tooltip":{"openState":"Открыть","closeState":"Закрыть"}}},"secondaryContentBar":{"label":"Оглавление","tocFilterButton":{"tooltip":"Отфильтровать на основе разделов"},"tocCollapseAllButton":{"tooltip":{"openState":"Раскрыть все","closeState":"Закрыть все"}}},"asideLayout":{"tagBarLabel":"Тематические разделы","tagBar":{"cleanFilterButton":"Все разделы"}}}},"book__chapter":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"secondaryContentBar":{"editOnGithubButton":{"tooltip":"Редактировать на Github"}}}},"what-is-new__toc":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"primaryContentBar":{"label":"История нововведений"},"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"}}}},"not-found":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"notFound_404":{"status":"404","title":"Страница не найдена :("}}},"pdf":{"metadata":{"title":"TypeScript - в деталях","description":"Бесплатная pdf книга на русском по языку TypeScript."},"gui":{"title":"TypeScript Подробное Руководство","subtitle":"PDF Версия"}}}},"pageContentData":{"title":"Утверждение типов (Type Assertion)","section":"Типизация","path":"utverjdenie tipov (type assertion)","subtitles":[{"subtitle":"Утверждение типов - общее","path":"utverjdenie tipov (type assertion)#utverjdenie tipov - obshchee"},{"subtitle":"Утверждение типа с помощью <Type> синтаксиса","path":"utverjdenie tipov (type assertion)#utverjdenie tipa s pomoshchu <type> sintaksisa"},{"subtitle":"Утверждение типа с помощью оператора as","path":"utverjdenie tipov (type assertion)#utverjdenie tipa s pomoshchu operatora as"},{"subtitle":"Приведение (утверждение) к константе (const assertion)","path":"utverjdenie tipov (type assertion)#privedenie (utverjdenie) k konstante (const assertion)"},{"subtitle":"Утверждение в сигнатуре (Signature Assertion)","path":"utverjdenie tipov (type assertion)#utverjdenie v signature (signature assertion)"}],"html":"<section class=\"content__section\" id=\"\"><h1 class=\"content__heading_1 main-title\">\n    <button class=\"content__button_copy-to-buffer\" path=\"\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Утверждение типов (Type Assertion)</span></h1><p class=\"content__paragraph\">Получение значения, которое несоответствует ожидаемому типу, является обычным делом для типизированных языков. Понимание причин, лежащих в основе несоответствий, а также всевозможные способы их разрешений, являются целями данной главы. </p></section>\n<section class=\"content__section\" id=\"Utverjdenie_tipov_-_obshchee\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"Utverjdenie_tipov_-_obshchee\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Утверждение типов - общее</span></h2><p class=\"content__paragraph\">При разработке приложений на языках со статической типизацией, время от времени может возникнуть нестыковка из-за несоответствия типов. Простыми словами, приходится работать с объектом, принадлежащим к известному типу, но ограниченному более специализированным (менее конкретным) интерфейсом.</p><p class=\"content__paragraph\">В <em>TypeScript</em> большинство операций с несоответствием типов приходится на работу с <em>dom</em> (<em>Document Object Model</em>).</p><p class=\"content__paragraph\">В качестве примера можно рассмотреть работу с таким часто используемым методом, как <code>querySelector()</code>. Но для начала вспомним, что в основе составляющих иерархию dom-дерева объектов лежит базовый тип <code>Node</code>, наделенный минимальными признаками, необходимыми для построения коллекции. Базовый тип <code>Node</code>, в том числе, расширяет и тип <code>Element</code>, который является базовым для всех элементов dom-дерева и обладает знакомыми всем признаками, необходимыми для работы с элементами dom, такими как атрибуты (<code>attributes</code>), список классов (<code>classList</code>), размеры клиента (<code>client*</code>) и другими. Элементы dom-дерева можно разделить на те, что не отображаются (унаследованные от <code>Element</code>, как например <code>script</code>, <code>link</code>) и те, что отображаются (например <code>div</code>, <code>body</code>). Последние имеют в своей иерархии наследования тип <code>HTMLElement</code>, расширяющий <code>Element</code>, который привносит признаки, присущие отображаемым объектам, как например координаты, стили, свойство <code>dataset</code> и т.д.</p><p class=\"content__paragraph\">Возвращаясь к методу <code>querySelector()</code>, стоит уточнить, что результатом его вызова может стать любой элемент, находящийся в dom-дереве. Если бы в качестве типа возвращаемого значения был указан тип <code>HTMLElement</code>, то операция получения элемента <code>&#x3C;script></code> или <code>&#x3C;link></code> завершилась бы неудачей, так как они не принадлежат к этому типу. Именно поэтому методу <code>querySelector()</code> в качестве типа возвращаемого значения указан более базовый тип <code>Element</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// &lt;canvas id=\"stage\" data-inactive=\"false\">&lt;/canvas></span>\n\n<span class=\"token keyword\">const</span> element<span class=\"token operator\">:</span> Element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#stage'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> stage<span class=\"token operator\">:</span> HTMLElement <span class=\"token operator\">=</span> element <span class=\"token comment\">// Error, Element is not assignable to type HTMLElement</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но, при попытке обратится к свойству <code>dataset</code> через объект, полученный с помощью <code>querySelector()</code>, возникнет ошибка, так как у типа <code>Element</code> отсутствует данное свойство. Факт, что разработчику известен тип, к которому принадлежит объект по указанному им селектору, дает ему основания попросить вывод типов пересмотреть свое отношение к типу конкретного объекта.</p><p class=\"content__paragraph\"><em>Попросить</em> - дословно означает, что разработчик может лишь попросить вывод типов пересмотреть отношение к типу. Но решение разрешить операцию или нет все равно остается за последним.</p><p class=\"content__paragraph\">Выражаясь человеческим языком, в <em>TypeScript</em> процесс, вынуждающий вывод типов пересмотреть свое отношение к какому-либо типу, называется <em>утверждением типа</em> (<code>Type Assertion</code>).</p><p class=\"content__paragraph\">Формально утверждение типа похоже на <em>преобразование</em> (приведение) типов (<em>type conversion</em>, <em>typecasting</em>), но, поскольку в скомпилированном коде от типов не остается и следа, то, по факту, это совершенно другой механизм. Именно поэтому он и называется <em>утверждение</em>. Утверждая тип, разработчик говорит компилятору — <em>“поверь мне, я знаю, что делаю”</em> (<em>Trust me, I know what I'm doing</em>).</p><p class=\"content__paragraph\">Нельзя не уточнить, что , хотя в <em>TypeScript</em> и существует термин утверждение типа, по ходу изложения в качестве синонимов будут употребляться слова преобразование, реже — приведение. А так же, не будет лишним напомнить, что приведение — это процесс в котором объект одного типа преобразуется в объект другого типа.</p></section>\n<section class=\"content__section\" id=\"Utverjdenie_tipa_s_pomoshchu_<Type>_sintaksisa\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"Utverjdenie_tipa_s_pomoshchu_<Type>_sintaksisa\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Утверждение типа с помощью &#x3C;Type> синтаксиса</span></h2><p class=\"content__paragraph\">Одним из способов указать компилятору на принадлежность значения к заданному типу является механизм утверждения типа при помощи угловых скобок <code>&#x3C;ConcreteType></code>, заключающих в себе конкретный тип, к которому и будет выполняться преобразование. Утверждение типа располагается строго перед выражением, результатом выполнения которого, будет преобразуемый тип.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token operator\">&lt;</span>ToType<span class=\"token operator\">></span>FromType</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Перепишем предыдущий код и исправим в нем ошибку, связанную с несоответствием типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// &lt;canvas id=\"stage\" data-inactive=\"false\">&lt;/canvas></span>\n\n<span class=\"token keyword\">const</span> element<span class=\"token operator\">:</span> Element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#stage'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> stage<span class=\"token operator\">:</span> HTMLElement <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>HTMLElement<span class=\"token operator\">></span>element <span class=\"token comment\">// Ok</span>\nstage<span class=\"token punctuation\">.</span>dataset<span class=\"token punctuation\">.</span>inactive <span class=\"token operator\">=</span> <span class=\"token string\">'true'</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если тип, к которому разработчик просит преобразовать компилятор, не совместим с преобразуемым типом, то в процессе утверждения возникнет ошибка.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bird</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Fish</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">swim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> bird<span class=\"token operator\">:</span> Bird <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bird</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> fish<span class=\"token operator\">:</span> Fish <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>Fish<span class=\"token operator\">></span>bird<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка, 'Bird' не может быть преобразован в 'Fish'</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Кроме того, существуют ситуации, в которых возникает необходимость множественного последовательного преобразования. Ярким примером являются значения полученные от <em>dom</em> элементов, которые воспринимаются разработчиком как числовые или логические, но по факту принадлежат к строковому типу.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// &lt;div id=\"#container\">&lt;/div></span>\n\n<span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#container'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> HTMLElement<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> width<span class=\"token punctuation\">,</span> height <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> area<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> width <span class=\"token operator\">*</span> height<span class=\"token punctuation\">;</span> <span class=\"token comment\">// ошибка -> width и height типа 'string'</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Дело в том, что в <em>TypeScript</em> невозможно привести тип <code>string</code> к типу <code>number</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// &lt;div id=\"#container\">&lt;/div></span>\n\n<span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#container'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> HTMLElement<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> width<span class=\"token operator\">:</span> widthString<span class=\"token punctuation\">,</span> height<span class=\"token operator\">:</span> heightString <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span>widthString<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка -> тип 'string' не может быть преобразован  в 'number'</span>\n<span class=\"token keyword\">let</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span>heightString<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка -> тип 'string' не может быть преобразован  в 'number'</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но осуществить задуманное можно преобразовав тип <code>string</code> сначала в тип <code>any</code>, а уже затем — в тип <code>number</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// &lt;div id=\"#container\">&lt;/div></span>\n\n<span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#container'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> HTMLElement<span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span> width<span class=\"token operator\">:</span> widthString<span class=\"token punctuation\">,</span> height<span class=\"token operator\">:</span> heightString <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>style<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> width<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span>widthString<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\n<span class=\"token keyword\">let</span> height<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token builtin\">number</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span>heightString<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\n\n<span class=\"token keyword\">let</span> area<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> width <span class=\"token operator\">*</span> height<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Стоит также заметить, что данный способ утверждения типа, кроме синтаксиса, больше ничем не отличается от указания с помощью оператора <code>as</code>.</p></section>\n<section class=\"content__section\" id=\"Utverjdenie_tipa_s_pomoshchu_operatora_as\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"Utverjdenie_tipa_s_pomoshchu_operatora_as\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Утверждение типа с помощью оператора as</span></h2><p class=\"content__paragraph\">В отличие от синтаксиса угловых скобок, которые указываются перед преобразуемым типом, оператор <code>as</code> указывается между преобразуемым и типом, и типом к которому требуется преобразовать.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">FromType <span class=\"token keyword\">as</span> ToType</code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Для демонстрации оператора <code>as</code> рассмотрим ещё один часто встречающийся случай, требующий утверждения типов.</p><p class=\"content__paragraph\">Обычное дело: при помощи метода <code>querySelector()</code> получить объект, принадлежащий к типу <code>HTMLElement</code> и подписать его на событие <code>click</code>. Задача заключается в том, что , при возникновении события, нужно изменить значение поля <code>dataset</code>, объявленного в типе <code>HTMLElement</code>. Было бы нерационально снова получать ссылку на объект при помощи метода <code>querySelector()</code>, ведь нужный объект хранится в свойстве объекта события <code>target</code>. Но дело в том, что свойство <code>target</code> имеет тип <code>EventTarget</code>, который не находится в иерархической зависимости с типом <code>HTMLElement</code> имеющим нужное свойство <code>dataset</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// &lt;span id=\"counter\">&lt;/span></span>\n\n<span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#counter'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> HTMLElement<span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>dataset<span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nelement<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> target <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> count<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> target<span class=\"token punctuation\">.</span>dataset<span class=\"token punctuation\">.</span>count<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error -> Property 'dataset' does not exist on type 'EventTarget'</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но эту проблему легко решить с помощью оператора утверждения типа <code>as</code>. Кроме того, с помощью этого же оператора можно привести тип <code>string</code>, к которому принадлежат все свойства находящиеся в <code>dataset</code>, к типу <code>any</code>, а уже затем к типу <code>number</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">querySelector</span><span class=\"token punctuation\">(</span><span class=\"token string\">'#counter'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> HTMLElement<span class=\"token punctuation\">;</span>\nelement<span class=\"token punctuation\">.</span>dataset<span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nelement<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span><span class=\"token string\">'click'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> target <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> element <span class=\"token operator\">=</span> target <span class=\"token keyword\">as</span> HTMLElement<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> count<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> element<span class=\"token punctuation\">.</span>dataset<span class=\"token punctuation\">.</span>count <span class=\"token keyword\">as</span> <span class=\"token builtin\">any</span> <span class=\"token keyword\">as</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n\n    element<span class=\"token punctuation\">.</span>dataset<span class=\"token punctuation\">.</span>count <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">++</span>count<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В случае несовместимости типов возникнет ошибка.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Bird</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">fly</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Fish</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">public</span> <span class=\"token function\">swim</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> bird<span class=\"token operator\">:</span> Bird <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Bird</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">let</span> fish<span class=\"token operator\">:</span> Fish <span class=\"token operator\">=</span> bird <span class=\"token keyword\">as</span> Fish<span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка, 'Bird' не может быть преобразован в 'Fish'</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Ещё одна острая необходимость, требующая утверждения типа, возникает тогда, когда разработчику приходится работать с объектом, ссылка на который ограничена более общим типом, как например <code>any</code>.</p><p class=\"content__paragraph\">Факт, что над значением, принадлежащему к типу <code>any</code>, разрешено выполнение любых операций, означает, что компилятор их не проверяет. Другими словами, разработчик, указывая тип <code>any</code>, усложняет процесс разработки, мешая компилятору проводить статический анализ кода, а также лишает себя помощи со стороны редактора кода. Когда разработчику известно к какому типу принадлежит значение, можно попросить компилятор изменить мнение о принадлежности значения к его типу с помощью механизма утверждения типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">DataProvider</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">readonly</span> data<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> provider<span class=\"token operator\">:</span> DataProvider <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">DataProvider</span><span class=\"token punctuation\">(</span><span class=\"token string\">'text'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">var</span> charAll<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> provider<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ок</span>\n<span class=\"token keyword\">var</span> charAll<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> provider<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span><span class=\"token function\">sPlIt</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка во время выполнения программы</span>\n<span class=\"token keyword\">var</span> charAll<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>provider<span class=\"token punctuation\">.</span>data <span class=\"token keyword\">as</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ок</span>\n\n<span class=\"token keyword\">let</span> dataString<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span> <span class=\"token operator\">=</span> provider<span class=\"token punctuation\">.</span>data <span class=\"token keyword\">as</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> charAll<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> dataString<span class=\"token punctuation\">.</span><span class=\"token function\">split</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ок</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Напоследок, стоит сказать, что выражения, требующие <em>утверждения типа</em>, при работе с <em>dom api</em> — это неизбежность. Кроме того, для работы с методом <code>document.querySelector()</code>, который был использован в примерах к этой главе, вместо приведения типов с помощью операторов <code>&#x3C;Type></code> или <code>as</code> предпочтительней конкретизировать тип с помощью обобщения, которые рассматриваются в главе <a href=\"/book/chapters/%D0%9E%D0%B1%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%20(Generics)\">“Типы - Обобщения (Generics)”</a>. Но в случае, если утверждение требуется для кода, написанного самим разработчиком, то, скорее всего, это следствие плохо продуманной архитектуры.</p></section>\n<section class=\"content__section\" id=\"Privedenie_(utverjdenie)_k_konstante_(const_assertion)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"Privedenie_(utverjdenie)_k_konstante_(const_assertion)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Приведение (утверждение) к константе (const assertion)</span></h2><p class=\"content__paragraph\">Ни для кого не секрет, что с точки зрения <em>JavaScript</em>, а следовательно и <em>TypeScript</em>, все примитивные литеральные значения являются константными значениями. С точки зрения среды исполнения два эквивалентных литерала любого литерального типа являются единым значением. То есть, среда исполнения расценивает два строковых литерала <code>'text'</code> и <code>'text'</code> как один литерал. Тоже справедливо и для остальных литералов, к которым помимо типа <code>string</code> также относятся типы <code>number</code>, <code>boolean</code> и <code>symbol</code>.</p><p class=\"content__paragraph\">Тем не менее, сложно найти разработчика <em>TypeScript</em>, не испытавшего трудностей, создаваемых выводом типов, при определении конструкций, которым предстоит проверка на принадлежность к литеральному типу.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Status</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span> <span class=\"token operator\">|</span> <span class=\"token number\">404</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Request</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> Status <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> status <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> request<span class=\"token operator\">:</span> Request <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> status <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error, TS2322: Type 'number' is not assignable to type 'Status'.</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В коде выше ошибка возникает по причине того, что вывод типов определяет принадлежность значения переменной <code>status</code> к типу <code>number</code>, а не литеральному числовому типу <code>200</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// вывод типов видит как</span>\n<span class=\"token keyword\">let</span> status<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span>\n\n<span class=\"token comment\">// в, то время как требуется так</span>\n<span class=\"token keyword\">let</span> port<span class=\"token operator\">:</span> <span class=\"token number\">200</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Прежде всего не будет лишним упомянуть, что данную проблему можно решить с помощью механизма утверждения при помощи таких операторов как <code>as</code> и угловых скобок <code>&#x3C;></code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Status</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span> <span class=\"token operator\">|</span> <span class=\"token number\">404</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Request</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> Status <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> status <span class=\"token operator\">=</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// утверждаем компилятору..</span>\n<span class=\"token keyword\">let</span> request<span class=\"token operator\">:</span> Request <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> status <span class=\"token keyword\">as</span> <span class=\"token number\">200</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ...с помощью as оператора</span>\n<span class=\"token comment\">// let request: Request = { status: &lt;200>status }; // ...или с помощью угловых скобок</span>\n<span class=\"token comment\">// ..., что он должен рассматривать значение, ассоциированное с as, как значение, принадлежащие к литеральному типу '200'</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но лучшим решением будет специально созданный для подобных случаев механизм, позволяющий производить утверждение к константе.</p><p class=\"content__paragraph\">Константное утверждение производится с помощью оператора <code>as</code> или угловых скобок <code>&#x3C;></code> и говорит компилятору, что значение является константным.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">Status</span> <span class=\"token operator\">=</span> <span class=\"token number\">200</span> <span class=\"token operator\">|</span> <span class=\"token number\">404</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Request</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> Status <span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> status <span class=\"token operator\">=</span> <span class=\"token number\">200</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// let status = &lt;const>200;</span>\n\n<span class=\"token keyword\">let</span> request<span class=\"token operator\">:</span> Request <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> status <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Утверждение, что значение является константным, заставляет вывод типов расценивать его как принадлежащее к литеральному типу. Утверждение к константе массива заставляет вывод типов определять его принадлежность к типу <code>readonly tuple</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token number\">404</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let a: number[]</span>\n\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token number\">404</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let b: readonly [200, 404]</span>\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">const</span><span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token number\">200</span><span class=\"token punctuation\">,</span> <span class=\"token number\">404</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let c: readonly [200, 404]</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В случае с объектным типом, утверждение к константе рекурсивно помечает все его поля как <code>readonly</code>. Кроме того, все его поля, принадлежащие к примитивным типам, расцениваются как литеральные типы.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">type</span> <span class=\"token class-name\">NotConstResponseType</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    status<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        role<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">ConstResponseType</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    status<span class=\"token operator\">:</span> <span class=\"token number\">200</span> <span class=\"token operator\">|</span> <span class=\"token number\">404</span><span class=\"token punctuation\">;</span>\n    data<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        role<span class=\"token operator\">:</span> <span class=\"token string\">'user'</span> <span class=\"token operator\">|</span> <span class=\"token string\">'admin'</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> data<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> role<span class=\"token operator\">:</span> <span class=\"token string\">'user'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// NotConstResponseType</span>\n\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> data<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> role<span class=\"token operator\">:</span> <span class=\"token string\">'user'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ConstResponseType</span>\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span><span class=\"token keyword\">const</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span> status<span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span> data<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> role<span class=\"token operator\">:</span> <span class=\"token string\">'user'</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ConstResponseType</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но стоит помнить, что утверждение к константе применимо исключительно к литералам таких типов, как <code>number</code>, <code>string</code>, <code>boolean</code>, <code>array</code> и <code>object</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token string\">'value'</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok - 'value' является литералом, let a: \"value\"</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> <span class=\"token number\">100</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok - 100 является литералом, let b: 100</span>\n<span class=\"token keyword\">let</span> c <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok - true является литералом, let c: true</span>\n\n<span class=\"token keyword\">let</span> d <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok - [] является литералом, let d: readonly []</span>\n<span class=\"token keyword\">let</span> e <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok - {} является литералом, let e: {readonly f: 100}</span>\n\n<span class=\"token keyword\">let</span> value <span class=\"token operator\">=</span> <span class=\"token string\">'value'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let value: string</span>\n<span class=\"token keyword\">let</span> array <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let array: number[]</span>\n<span class=\"token keyword\">let</span> object <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let object: {f: number}</span>\n\n<span class=\"token keyword\">let</span> f <span class=\"token operator\">=</span> value <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка, value — это ссылка на идентификатор, хранящий литерал</span>\n<span class=\"token keyword\">let</span> g <span class=\"token operator\">=</span> array <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка, array — это ссылка на идентификатор, хранящий ссылку на массив</span>\n<span class=\"token keyword\">let</span> h <span class=\"token operator\">=</span> object <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка, object — это ссылка на идентификатор, хранящий ссылку на объект</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">После рассмотрения всех случаев утверждения к константе (примитивных, массивов и объектных типов) может сложиться впечатление, что в <em>TypeScript</em>, наконец, появились структуры, которые справедливо было бы назвать <em>полноценными константами</em>, неизменяемыми ни при каких условиях. И это, отчасти, действительно так. Но дело в том, что на данный момент, принадлежность объектных и массивоподобных типов к константе зависит от значений, с которыми они ассоциированы.</p><p class=\"content__paragraph\">В случае, когда литералы ссылочных типов (массивы и объекты) ассоциированы со значением также принадлежащим к ссылочному типу, они представляются такими, какими были на момент ассоциации. Кроме того, поведение механизма приведения к константе зависит от другого механизма — деструктуризации.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> defaultObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let defaultObject: {f: number}</span>\n<span class=\"token keyword\">let</span> constObject <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let constObject: {readonly f: 100}</span>\n\n<span class=\"token keyword\">let</span> defaultArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let defaultArray: number[]</span>\n<span class=\"token keyword\">let</span> constArray <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">]</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let constArray: readonly [0, 1, 2]</span>\n\n<span class=\"token comment\">// o0 иммутабельный (неизменяемый) объект</span>\n<span class=\"token keyword\">let</span> o0 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> <span class=\"token number\">100</span> <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {readonly f: {readonly f: 100}}</span>\n<span class=\"token comment\">// o1.f имеет модификатор readonly, o1.f.f - мутабельный (изменяемый) объект</span>\n<span class=\"token keyword\">let</span> o1 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> defaultObject <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {readonly f: {f: number}}</span>\n<span class=\"token comment\">// o2 иммутабельный (неизменяемый) объект</span>\n<span class=\"token keyword\">let</span> o2 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>defaultObject <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {readonly f: number}</span>\n<span class=\"token comment\">// o3.f и o3.f.f иммутабельные (неизменяемые) объекты</span>\n<span class=\"token keyword\">let</span> o3 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>defaultObject <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {readonly f: {readonly f: number}}</span>\n\n<span class=\"token comment\">// o4.f и o4.f.f иммутабельные (неизменяемые) объекты</span>\n<span class=\"token keyword\">let</span> o4 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> constObject <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let o4: {readonly f: {readonly f: 100}}</span>\n<span class=\"token comment\">// o5 иммутабельный (неизменяемый) объект</span>\n<span class=\"token keyword\">let</span> o5 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>constObject <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let o5: {readonly f: 100}</span>\n<span class=\"token comment\">// o6 иммутабельный (неизменяемый) объект</span>\n<span class=\"token keyword\">let</span> o6 <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> f<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">...</span>constObject <span class=\"token punctuation\">}</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// {readonly f: {readonly f: 100}}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">По причине, что объектные типы данных, хранящиеся в массиве, подчиняются описанным выше правилам, подробное рассмотрение процесса утверждения массива к константе будет опущено.</p><p class=\"content__paragraph\">И последнее, о чем стоит упомянуть — утверждение к константе применимо только к простым выражениям.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> a <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">'yes'</span> <span class=\"token operator\">:</span> <span class=\"token string\">'no'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ошибка</span>\n<span class=\"token keyword\">let</span> b <span class=\"token operator\">=</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">round</span><span class=\"token punctuation\">(</span>Math<span class=\"token punctuation\">.</span><span class=\"token function\">random</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">*</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token string\">'yes'</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span> <span class=\"token operator\">:</span> <span class=\"token string\">'no'</span> <span class=\"token keyword\">as</span> <span class=\"token keyword\">const</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok, let b: \"yes\" | \"no\"</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>\n<section class=\"content__section\" id=\"Utverjdenie_v_signature_(Signature_Assertion)\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"Utverjdenie_v_signature_(Signature_Assertion)\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Утверждение в сигнатуре (Signature Assertion)</span></h2><p class=\"content__paragraph\">Помимо функций, реализующих механизм <em>утверждения типа</em>, в <em>TypeScript</em> существует механизм <em>утверждения в сигнатуре</em>, позволяющий определять утверждающие функции, вызов которых, в случае невыполнения условия, приводит к выбрасыванию исключения. Для того, что бы объявить утверждающую функцию, в её сигнатуре (там где располагается возвращаемое значение) следует указать ключевое слово <code>asserts</code>, а затем параметр принимаемого на вход условия.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">identifier</span><span class=\"token punctuation\">(</span>condition<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">asserts</span> condition <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Ключевой особенностью утверждения в сигнатуре является то, что в качестве аргумента утверждающая функция ожидает выражение, определяющие принадлежность к конкретному типу с помощью любого предназначенного для этого механизма (<code>typeof</code>, <code>instanceof</code> и даже с помощью механизма утверждения типов, реализуемого самим <em>TypeScript</em>).</p><p class=\"content__paragraph\">Если принадлежность значения к указанному типу подтверждается, то далее по коду компилятор будет рассматривать его в роли этого типа. Иначе выбрасывается исключение.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// утверждение в сигнатуре</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">isStringAssert</span><span class=\"token punctuation\">(</span>condition<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">asserts</span> condition <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>condition<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// утверждение типа</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> value <span class=\"token keyword\">is</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">typeof</span> value <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">testScope</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>text<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    text<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// до утверждения расценивается как тип any..</span>\n\n    <span class=\"token function\">isStringAssert</span><span class=\"token punctuation\">(</span>text <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// выражение с оператором instanceof</span>\n    <span class=\"token class-name\">isStringAssert</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> text <span class=\"token operator\">===</span> <span class=\"token string\">'string'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// выражение с оператором typeof</span>\n    <span class=\"token function\">isStringAssert</span><span class=\"token punctuation\">(</span><span class=\"token function\">isString</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// механизм \"утверждения типа\"</span>\n\n    text<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ..после утверждения, как тип string</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">При использовании механизма <em>утверждения в сигнатуре</em> с механизмом <em>утверждения типа</em>, условие можно перенести из вызова утверждающей функции в её тело.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">isStringAsserts</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">asserts</span> value <span class=\"token keyword\">is</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> value <span class=\"token operator\">!==</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">testScope</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>text<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    text<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// не является ошибкой, потому, что тип — any</span>\n\n    <span class=\"token function\">isStringAsserts</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// условие определено внутри утверждающей функции</span>\n\n    text<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// теперь ошибка, потому, что тип утвержден как string</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Стоит обратить внимание на то, что механизм утверждения типа не будет работать в случае переноса условного выражения в тело утверждающей функции, сигнатура которой, лишена <em>утверждения типов</em> и содержит исключительно <em>утверждения в сигнатуре</em>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">isStringAsserts</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">asserts</span> value <span class=\"token comment\">/** is string */</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> value <span class=\"token operator\">!==</span> <span class=\"token string\">\"string\"</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">testScope</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>text<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    text<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// не является ошибкой, потому, что тип — any</span>\n\n    <span class=\"token function\">isStringAsserts</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// условие определено в утверждающей функции</span>\n\n    text<span class=\"token punctuation\">.</span><span class=\"token function\">toUppercase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// нет ошибки, потому, что утверждение типов не работает</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div></section>","commitInfoAll":[{"committedDate":"2020-09-26T10:00:03Z","message":"www(исправление бага): fix reduce heading\n\nfix reduce heading","messageHeadline":"www(исправление бага): fix reduce heading","pushedDate":"2020-09-26T10:00:31Z","authoredByCommitter":true,"committer":{"name":"nauchikus","bio":"@TechnoFanatic(\"🍬\")\r\n","location":null,"avatarUrl":"https://avatars.githubusercontent.com/u/31518738?v=4"}},{"committedDate":"2021-01-07T14:20:47Z","message":"Update content.md","messageHeadline":"Update content.md","pushedDate":null,"authoredByCommitter":false,"committer":{"name":"antixrist","bio":"","location":null,"avatarUrl":"https://avatars.githubusercontent.com/u/2387592?u=cdbc0ec7d03968829a2942e11b8beeb0b7e41039&v=4"}},{"committedDate":"2021-03-21T11:32:13Z","message":"fixed grammar and syntax errors in the text, corrected links","messageHeadline":"fixed grammar and syntax errors in the text, corrected links","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"mindyourlifeguide","bio":"Front-end developer","location":"Kyiv, Ukraine","avatarUrl":"https://avatars.githubusercontent.com/u/35348648?u=d52456eed154db660092623fe6e0ebb516677a95&v=4"}}],"fileOnGithubLink":"https://github.com/nauchikus/typescript-definitive-guide/blob/book/undefined/035\\.\\(Типизация\\) Утверждение типов \\(Type Assertion\\)/content.md"},"pageNavDataAll":[{"name":"Что такое и для чего нужен TypeScript","path":"Chto_takoe_i_dlya_chego_nujen_TypeScript","sections":[{"name":"Что такое TypeScript","path":"Chto_takoe_TypeScript"},{"name":"История TypeScript","path":"Istoriya_TypeScript"},{"name":"Для чего нужен TypeScript","path":"Dlya_chego_nujen_TypeScript"},{"name":"Зачем разработчику TypeScript","path":"Zachem_razrabotchiku_TypeScript"}]},{"name":"Вступление","path":"Vstuplenie","sections":[]},{"name":"Система типов, тип данных, значимые и ссылочные типы","path":"Sistema_tipov,tip_dannyh,znachimye_i_ssylochnye_tipy","sections":[{"name":"Система Типов","path":"Sistema_Tipov"},{"name":"Тип данных (тип)","path":"Tip_dannyh_(tip)"},{"name":"Тип данных, передающийся по значению (примитивный тип)","path":"Tip_dannyh,peredaushchiisya_po_znacheniu_(primitivnyi_tip)"},{"name":"Тип данных, передающийся по ссылке","path":"Tip_dannyh,peredaushchiisya_po_ssylke"}]},{"name":"Связывание, типизация, вывод типов","path":"Svyazyvanie,tipizaciya,vyvod_tipov","sections":[{"name":"Обработка кода компилятором","path":"Obrabotka_koda_kompilyatorom"},{"name":"Лексический анализ (токенизация - tokenizing)","path":"Leksicheskii_analiz_(tokenizaciya_-_tokenizing)"},{"name":"Синтаксический анализ (разбор - parsing)","path":"Sintaksicheskii_analiz_(razbor_-_parsing)"},{"name":"Семантический анализ","path":"Semanticheskii_analiz"},{"name":"Связывание (Binding)","path":"Svyazyvanie_(Binding)"},{"name":"Типизация","path":"Tipizaciya"},{"name":"Вывод Типов (type inference)","path":"Vyvod_Tipov_(type_inference)"}]},{"name":"Преобразование типов","path":"Preobrazovanie_tipov","sections":[{"name":"Неявные Преобразования","path":"Neyavnye_Preobrazovaniya"},{"name":"Явные Преобразования","path":"Yavnye_Preobrazovaniya"}]},{"name":"Типизированные и нетипизированные языки программирования","path":"Tipizirovannye_i_netipizirovannye_yazyki_programmirovaniya","sections":[{"name":"Нетипизированные языки","path":"Netipizirovannye_yazyki"},{"name":"Типизированные языки","path":"Tipizirovannye_yazyki"}]},{"name":"Статическая и динамическая типизация","path":"Staticheskaya_i_dinamicheskaya_tipizaciya","sections":[{"name":"Статическая типизация (Static Typing)","path":"Staticheskaya_tipizaciya_(Static_Typing)"},{"name":"Динамическая Типизация (Dynamic Typing)","path":"Dinamicheskaya_Tipizaciya_(Dynamic_Typing)"}]},{"name":"Сильная и слабая типизация","path":"Silnaya_i_slabaya_tipizaciya","sections":[{"name":"Сильная типизация (strongly typed)","path":"Silnaya_tipizaciya_(strongly_typed)"},{"name":"Слабая типизация (weakly typed)","path":"Slabaya_tipizaciya_(weakly_typed)"}]},{"name":"Явная и неявная типизация","path":"Yavnaya_i_neyavnaya_tipizaciya","sections":[{"name":"Явная типизация (explicit typing)","path":"Yavnaya_tipizaciya_(explicit_typing)"},{"name":"Неявная типизация (implicit typing)","path":"Neyavnaya_tipizaciya_(implicit_typing)"}]},{"name":"Совместимость типов на основе вида типизации","path":"Sovmestimost_tipov_na_osnove_vida_tipizacii","sections":[{"name":"Совместимость типов (Types Compatibility)","path":"Sovmestimost_tipov_(Types_Compatibility)"},{"name":"Номинативная Типизация (nominative typing)","path":"Nominativnaya_Tipizaciya_(nominative_typing)"},{"name":"Структурная Типизация (structural typing)","path":"Strukturnaya_Tipizaciya_(structural_typing)"},{"name":"Утиная Типизация (Duck typing)","path":"Utinaya_Tipizaciya_(Duck_typing)"}]},{"name":"Совместимость типов на основе вариантности","path":"Sovmestimost_tipov_na_osnove_variantnosti","sections":[{"name":"Вариантность","path":"Variantnost"},{"name":"Иерархия наследования","path":"Ierarhiya_nasledovaniya"},{"name":"Ковариантность","path":"Kovariantnost"},{"name":"Контравариантность","path":"Kontravariantnost"},{"name":"Инвариантность","path":"Invariantnost"},{"name":"Бивариантность","path":"Bivariantnost"}]},{"name":"Аннотация Типов","path":"Annotaciya_Tipov","sections":[{"name":"Аннотация Типов - общее","path":"Annotaciya_Tipov_-_obshchee"},{"name":"Аннотация типа","path":"Annotaciya_tipa"},{"name":"Синтаксические конструкции var, let, const","path":"Sintaksicheskie_konstrukcii_var,let,const"},{"name":"Функции (function)","path":"Funkcii_(function)"},{"name":"Стрелочные Функции (arrow function)","path":"Strelochnye_Funkcii_(arrow_function)"},{"name":"Классы (class)","path":"Klassy_(class)"},{"name":"Сравнение Синтаксиса TypeScript и JavaScript","path":"Sravnenie_Sintaksisa_TypeScript_i_JavaScript"},{"name":"Итог","path":"Itog"}]},{"name":"Базовый Тип Any","path":"Bazovyi_Tip_Any","sections":[{"name":"Any (any) произвольный тип","path":"Any_(any)_proizvolnyi_tip"}]},{"name":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"Primitivnye_tipy_Number,String,Boolean,Symbol,BigInt","sections":[{"name":"Важно","path":"Vajno"},{"name":"Number (number) примитивный числовой тип","path":"Number_(number)_primitivnyi_chislovoi_tip"},{"name":"String (string) примитивный строковый тип","path":"String_(string)_primitivnyi_strokovyi_tip"},{"name":"Boolean (boolean) примитивный логический тип","path":"Boolean_(boolean)_primitivnyi_logicheskii_tip"},{"name":"Symbol (symbol) примитивный символьный тип","path":"Symbol_(symbol)_primitivnyi_simvolnyi_tip"},{"name":"BigInt (bigint) примитивный числовой тип","path":"BigInt_(bigint)_primitivnyi_chislovoi_tip"}]},{"name":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"Primitivnye_tipy_Null,Undefined,Void,Never,Unknown","sections":[{"name":"Важно","path":"Vajno"},{"name":"Null (null) примитивный null тип","path":"Null_(null)_primitivnyi_null_tip"},{"name":"Undefined (undefined) примитивный неопределенный тип","path":"Undefined_(undefined)_primitivnyi_neopredelennyi_tip"},{"name":"Void (void) отсутствие конкретного типа","path":"Void_(void)_otsutstvie_konkretnogo_tipa"},{"name":"Never (never) примитивный тип","path":"Never_(never)_primitivnyi_tip"},{"name":"Unknown (unknown)","path":"Unknown_(unknown)"}]},{"name":"Примитивный Тип Enum","path":"Primitivnyi_Tip_Enum","sections":[{"name":"Enum (enum) примитивный перечисляемый тип","path":"Enum_(enum)_primitivnyi_perechislyaemyi_tip"},{"name":"Перечисления с числовым значением","path":"Perechisleniya_s_chislovym_znacheniem"},{"name":"Перечисления со строковым значением","path":"Perechisleniya_so_strokovym_znacheniem"},{"name":"Смешанное перечисление (mixed enum)","path":"Smeshannoe_perechislenie_(mixed_enum)"},{"name":"Перечисление в качестве типа данных","path":"Perechislenie_v_kachestve_tipa_dannyh"},{"name":"Перечисление const с числовым и строковым значением","path":"Perechislenie_const_s_chislovym_i_strokovym_znacheniem"},{"name":"Когда стоит применять enum?","path":"Kogda_stoit_primenyat_enum?"}]},{"name":"Типы - Union, Intersection","path":"Tipy_-_Union,Intersection","sections":[{"name":"Тип Объединение (Union Types)","path":"Tip_Obedinenie_(Union_Types)"},{"name":"Тип Пересечение (Intersection Type)","path":"Tip_Peresechenie_(Intersection_Type)"}]},{"name":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"Type_Queries_(zaprosy_tipa),Alias_(psevdonimy_tipa)","sections":[{"name":"Запросы Типа (Type Queries)","path":"Zaprosy_Tipa_(Type_Queries)"},{"name":"Псевдонимы Типов (Type Aliases)","path":"Psevdonimy_Tipov_(Type_Aliases)"}]},{"name":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","path":"Primitivnye_literalnye_tipy_Number,String,Template_String,Boolean,Unique_Symbol,Enum","sections":[{"name":"Литеральный тип Number (Numeric Literal Types)","path":"Literalnyi_tip_Number_(Numeric_Literal_Types)"},{"name":"Литеральный тип String (String Literal Types)","path":"Literalnyi_tip_String_(String_Literal_Types)"},{"name":"Шаблонный литеральный тип String (Template String Literal Types)","path":"Shablonnyi_literalnyi_tip_String_(Template_String_Literal_Types)"},{"name":"Литеральный Тип Boolean (Boolean Literal Types)","path":"Literalnyi_Tip_Boolean_(Boolean_Literal_Types)"},{"name":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"Literalnyi_Tip_Unique_Symbol_(unique_symbol)_unikalnyi_simvolnyi_tip"},{"name":"Литеральный тип Enum (Enum Literal Types)","path":"Literalnyi_tip_Enum_(Enum_Literal_Types)"}]},{"name":"Object, Array, Tuple","path":"Object,Array,Tuple","sections":[{"name":"Object (object) — ссылочный объектный тип","path":"Object_(object)_—_ssylochnyi_obektnyi_tip"},{"name":"Array (type[]) ссылочный массивоподобный тип","path":"Array_(type[])_ssylochnyi_massivopodobnyi_tip"},{"name":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"Tuple_([T0,T1,…,Tn])_tip_kortej"}]},{"name":"Function, Functional Types","path":"Function,Functional_Types","sections":[{"name":"Function Types - тип функция","path":"Function_Types_-_tip_funkciya"},{"name":"Functional Types - функциональный тип","path":"Functional_Types_-_funkcionalnyi_tip"},{"name":"this в сигнатуре функции","path":"this_v_signature_funkcii"}]},{"name":"Interfaces","path":"Interfaces","sections":[{"name":"Общая теория","path":"Obshchaya_teoriya"},{"name":"Интерфейс в TypeScript","path":"Interfeis_v_TypeScript"},{"name":"Объявление (declaration)","path":"Obyavlenie_(declaration)"},{"name":"Конвенции именования интерфейсов","path":"Konvencii_imenovaniya_interfeisov"},{"name":"Реализация интерфейса (implements)","path":"Realizaciya_interfeisa_(implements)"},{"name":"Декларация свойств get и set (accessors)","path":"Deklaraciya_svoistv_get_i_set_(accessors)"},{"name":"Указание интерфейса в качестве типа (interface types)","path":"Ukazanie_interfeisa_v_kachestve_tipa_(interface_types)"},{"name":"Расширение интерфейсов (extends interface)","path":"Rasshirenie_interfeisov_(extends_interface)"},{"name":"Расширение интерфейсом класса (extends class)","path":"Rasshirenie_interfeisom_klassa_(extends_class)"},{"name":"Описание класса (функции-конструктора)","path":"Opisanie_klassa_(funkcii-konstruktora)"},{"name":"Описание функционального выражения","path":"Opisanie_funkcionalnogo_vyrajeniya"},{"name":"Описание индексных членов в объектных типов","path":"Opisanie_indeksnyh_chlenov_v_obektnyh_tipov"},{"name":"Инлайн интерфейсы (Inline Interface)","path":"Inlain_interfeisy_(Inline_Interface)"},{"name":"Слияние интерфейсов","path":"Sliyanie_interfeisov"}]},{"name":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"Obektnye_tipy_s_indeksnymi_chlenami_(obektnyi_tip_s_dinamicheskimi_kluchami)","sections":[{"name":"Индексные члены (определение динамических ключей)","path":"Indeksnye_chleny_(opredelenie_dinamicheskih_kluchei)"},{"name":"Строгая проверка при обращении к динамическим ключам","path":"Strogaya_proverka_pri_obrashchenii_k_dinamicheskim_klucham"},{"name":"Запрет обращения к динамическим ключам через точечную нотацию","path":"Zapret_obrashcheniya_k_dinamicheskim_klucham_cherez_tochechnuu_notaciu"},{"name":"Тонкости совместимости индексной сигнатурой с необязательными полями","path":"Tonkosti_sovmestimosti_indeksnoi_signaturoi_s_neobyazatelnymi_polyami"}]},{"name":"Модификаторы доступа (Access Modifiers)","path":"Modifikatory_dostupa_(Access_Modifiers)","sections":[{"name":"Модификатор доступа public (публичный)","path":"Modifikator_dostupa_public_(publichnyi)"},{"name":"Модификатор доступа private (закрытый или скрытый)","path":"Modifikator_dostupa_private_(zakrytyi_ili_skrytyi)"},{"name":"Модификатор доступа protected (защищенный)","path":"Modifikator_dostupa_protected_(zashchishchennyi)"},{"name":"Модификаторы доступа и конструкторы класса","path":"Modifikatory_dostupa_i_konstruktory_klassa"},{"name":"Быстрое объявление полей","path":"Bystroe_obyavlenie_polei"}]},{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"Zakrytye_polya_opredelennye_specifikaciei_ECMAScript","sections":[{"name":"Нативный закрытый (private) модификатор доступа","path":"Nativnyi_zakrytyi_(private)_modifikator_dostupa"}]},{"name":"Абстрактные классы (abstract classes)","path":"Abstraktnye_klassy_(abstract_classes)","sections":[{"name":"Общие характеристики","path":"Obshchie_harakteristiki"},{"name":"Теория","path":"Teoriya"}]},{"name":"Полиморфный тип this","path":"Polimorfnyi_tip_this","sections":[{"name":"this - как тип","path":"this_-_kak_tip"}]},{"name":"Модификатор readonly (только для чтения)","path":"Modifikator_readonly_(tolko_dlya_chteniya)","sections":[{"name":"Модификатор readonly","path":"Modifikator_readonly"}]},{"name":"Definite Assignment Assertion Modifier","path":"Definite_Assignment_Assertion_Modifier","sections":[{"name":"Модификатор утверждения не принадлежности значения к типу undefined","path":"Modifikator_utverjdeniya_ne_prinadlejnosti_znacheniya_k_tipu_undefined"}]},{"name":"Классы — Тонкости","path":"Klassy_—_Tonkosti","sections":[{"name":"Классы - Тонкости implements","path":"Klassy_-_Tonkosti_implements"},{"name":"Частичное слияние интерфейса с классом","path":"Chastichnoe_sliyanie_interfeisa_s_klassom"},{"name":"Переопределение свойств полями и наоборот при наследовании","path":"Pereopredelenie_svoistv_polyami_i_naoborot_pri_nasledovanii"}]},{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"Razlichiya_var,let,const_i_modifikatora_readonly_pri_neyavnom_ukazanii_primitivnyh_tipov","sections":[{"name":"Нюансы на практике","path":"Nuansy_na_praktike"}]},{"name":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","path":"Operatory_-_Optional,Not-Null_Not-Undefined,Definite_Assignment_Assertion","sections":[{"name":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"Neobyazatelnye_polya,parametry_i_metody_(Optional_Fields,Parameters_and_Methods)"},{"name":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"Operator_!_(Non-Null_and_Non-Undefined_Operator)"},{"name":"Оператор ! (Definite Assignment Assertion)","path":"Operator_!_(Definite_Assignment_Assertion)"}]},{"name":"Обобщения (Generics)","path":"Obobshcheniya_(Generics)","sections":[{"name":"Обобщения - общие понятия","path":"Obobshcheniya_-_obshchie_ponyatiya"},{"name":"Обобщения в TypeScript","path":"Obobshcheniya_v_TypeScript"},{"name":"Параметры типа - extends (generic constraints)","path":"Parametry_tipa_-_extends_(generic_constraints)"},{"name":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"Parametra_tipa_-_znachenie_po_umolchaniu_=_(generic_parameter_defaults)"},{"name":"Параметры типа - как тип данных","path":"Parametry_tipa_-_kak_tip_dannyh"}]},{"name":"Дискриминантное объединение (Discriminated Union)","path":"Diskriminantnoe_obedinenie_(Discriminated_Union)","sections":[{"name":"Дискриминантное объединение","path":"Diskriminantnoe_obedinenie"}]},{"name":"Импорт и экспорт только типа","path":"Import_i_eksport_tolko_tipa","sections":[{"name":"Предыстория возникновения import type и export type","path":"Predystoriya_vozniknoveniya_import_type_i_export_type"},{"name":"import type и export type - форма объявления","path":"import_type_i_export_type_-_forma_obyavleniya"},{"name":"Импорт и экспорт только типа на практике","path":"Import_i_eksport_tolko_tipa_na_praktike"},{"name":"Вспомогательный флаг --importsNotUsedAsValues","path":"Vspomogatelnyi_flag_--importsNotUsedAsValues"}]},{"name":"Утверждение типов (Type Assertion)","path":"Utverjdenie_tipov_(Type_Assertion)","sections":[{"name":"Утверждение типов - общее","path":"Utverjdenie_tipov_-_obshchee"},{"name":"Утверждение типа с помощью <Type> синтаксиса","path":"Utverjdenie_tipa_s_pomoshchu_<Type>_sintaksisa"},{"name":"Утверждение типа с помощью оператора as","path":"Utverjdenie_tipa_s_pomoshchu_operatora_as"},{"name":"Приведение (утверждение) к константе (const assertion)","path":"Privedenie_(utverjdenie)_k_konstante_(const_assertion)"},{"name":"Утверждение в сигнатуре (Signature Assertion)","path":"Utverjdenie_v_signature_(Signature_Assertion)"}]},{"name":"Защитники типа","path":"Zashchitniki_tipa","sections":[{"name":"Защитники Типа - общее","path":"Zashchitniki_Tipa_-_obshchee"},{"name":"Сужение диапазона множества типов на основе типа данных","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_tipa_dannyh"},{"name":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_priznakov_prisushchih_tipu_Tagged_Union"},{"name":"Сужение диапазона множества типов на основе доступных членов объекта","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_dostupnyh_chlenov_obekta"},{"name":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_funkcii,opredelennoi_polzovatelem"}]},{"name":"Вывод типов","path":"Vyvod_tipov","sections":[{"name":"Вывод типов - общие сведения","path":"Vyvod_tipov_-_obshchie_svedeniya"},{"name":"Вывод примитивных типов","path":"Vyvod_primitivnyh_tipov"},{"name":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"Vyvod_primitivnyh_tipov_dlya_konstant_(const)_i_polei_tolko_dlya_chteniya_(readonly)"},{"name":"Вывод объектных типов","path":"Vyvod_obektnyh_tipov"},{"name":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"Vyvod_tipa_dlya_polei_klassa_na_osnove_inicializacii_ih_v_konstruktore"},{"name":"Вывод объединенных (Union) типов","path":"Vyvod_obedinennyh_(Union)_tipov"},{"name":"Вывод пересечения (Intersection) с дискриминантными полями","path":"Vyvod_peresecheniya_(Intersection)_s_diskriminantnymi_polyami"},{"name":"Вывод типов кортеж (Tuple)","path":"Vyvod_tipov_kortej_(Tuple)"}]},{"name":"Совместимость объектных типов (Compatible Object Types)","path":"Sovmestimost_obektnyh_tipov_(Compatible_Object_Types)","sections":[{"name":"Важно","path":"Vajno"},{"name":"Совместимость объектных типов в TypeScript","path":"Sovmestimost_obektnyh_tipov_v_TypeScript"}]},{"name":"Совместимость функциональных типов (Compatible Function Types)","path":"Sovmestimost_funkcionalnyh_tipov_(Compatible_Function_Types)","sections":[{"name":"Важно","path":"Vajno"},{"name":"Совместимость параметров","path":"Sovmestimost_parametrov"},{"name":"Совместимость возвращаемого значения","path":"Sovmestimost_vozvrashchaemogo_znacheniya"}]},{"name":"Совместимость объединений (Union Types)","path":"Sovmestimost_obedinenii_(Union_Types)","sections":[{"name":"Совместимость","path":"Sovmestimost"}]},{"name":"Типизация в TypeScript","path":"Tipizaciya_v_TypeScript","sections":[{"name":"Общие сведения","path":"Obshchie_svedeniya"},{"name":"Статическая типизация (static typing)","path":"Staticheskaya_tipizaciya_(static_typing)"},{"name":"Сильная типизация (strongly typed)","path":"Silnaya_tipizaciya_(strongly_typed)"},{"name":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"Yavno_tipizirovannyi_(explicit_typing)_s_vyvodom_tipov_(type_inference)"},{"name":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"Sovmestimost_tipov_(Type_Compatibility),strukturnaya_tipizaciya_(structural_typing)"},{"name":"Вариантность (variance)","path":"Variantnost_(variance)"},{"name":"Наилучший общий тип (Best common type)","path":"Nailuchshii_obshchii_tip_(Best_common_type)"},{"name":"Контекстный тип (Contextual Type)","path":"Kontekstnyi_tip_(Contextual_Type)"}]},{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"Operator_keyof,Lookup_Types,Mapped_Types,Mapped_Types_-_prefiksy_+_i_-","sections":[{"name":"Запрос ключей keyof","path":"Zapros_kluchei_keyof"},{"name":"Поиск типов (Lookup Types)","path":"Poisk_tipov_(Lookup_Types)"},{"name":"Сопоставление типов (Mapped Types)","path":"Sopostavlenie_tipov_(Mapped_Types)"},{"name":"Префиксы + и - в сопоставленных типах","path":"Prefiksy_+_i_-_v_sopostavlennyh_tipah"}]},{"name":"Условные типы (Conditional Types)","path":"Uslovnye_tipy_(Conditional_Types)","sections":[{"name":"Условные типы на практике","path":"Uslovnye_tipy_na_praktike"},{"name":"Распределительные условные типы (Distributive Conditional Types)","path":"Raspredelitelnye_uslovnye_tipy_(Distributive_Conditional_Types)"},{"name":"Вывод типов в условном типе","path":"Vyvod_tipov_v_uslovnom_tipe"}]},{"name":"Readonly, Partial, Required, Pick, Record","path":"Readonly,Partial,Required,Pick,Record","sections":[{"name":"Readonly<T> (сделать члены объекта только для чтения)","path":"Readonly<T>_(sdelat_chleny_obekta_tolko_dlya_chteniya)"},{"name":"Partial<T> (сделать все члены объекта необязательными)","path":"Partial<T>_(sdelat_vse_chleny_obekta_neobyazatelnymi)"},{"name":"Required<T> (сделать все необязательные члены обязательными)","path":"Required<T>_(sdelat_vse_neobyazatelnye_chleny_obyazatelnymi)"},{"name":"Pick (отфильтровать объектный тип)","path":"Pick_(otfiltrovat_obektnyi_tip)"},{"name":"Record<K, T> (динамически определить поле в объектном типе)","path":"Record<K,T>_(dinamicheski_opredelit_pole_v_obektnom_tipe)"}]},{"name":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"Exclude,Extract,NonNullable,ReturnType,InstanceType,Omit","sections":[{"name":"Exclude<T, U> (исключает из T признаки присущие U)","path":"Exclude<T,U>_(iskluchaet_iz_T_priznaki_prisushchie_U)"},{"name":"Extract<T, U> (общие для двух типов признаки)","path":"Extract<T,U>_(obshchie_dlya_dvuh_tipov_priznaki)"},{"name":"NonNullable<T> (удаляет типы null и undefined)","path":"NonNullable<T>_(udalyaet_tipy_null_i_undefined)"},{"name":"ReturnType<T> (получить тип значения возвращаемого функцией)","path":"ReturnType<T>_(poluchit_tip_znacheniya_vozvrashchaemogo_funkciei)"},{"name":"InstanceType<T> (получить через тип класса тип его экземпляра)","path":"InstanceType<T>_(poluchit_cherez_tip_klassa_tip_ego_ekzemplyara)"},{"name":"Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)","path":"Parameters<T>_(poluchit_tip_razmechennogo_korteja_opisyvaushchii_parametry_funkcionalnogo_tipa)"},{"name":"ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)","path":"ConstructorParameters<T>_(poluchit_cherez_tip_klassa_razmechennyi_kortej_opisyvaushchii_parametry_ego_konstruktora)"},{"name":"Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)","path":"Omit<T,K>_(iskluchit_iz_T_priznaki_associirovannymi_s_kluchami_perechislennyh_mnojestvom_K)"}]},{"name":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"Massivopodobnye_readonly_tipy,ReadonlyArray,ReadonlyMap,ReadonlySet","sections":[{"name":"Массивоподобные readonly типы (модифицировать непосредственно в аннотации типа)","path":"Massivopodobnye_readonly_tipy_(modificirovat_neposredstvenno_v_annotacii_tipa)"},{"name":"ReadonlyArray<T> (неизменяемый массив)","path":"ReadonlyArray<T>_(neizmenyaemyi_massiv)"},{"name":"ReadonlyMap<K, V> (неизменяемая карта)","path":"ReadonlyMap<K,V>_(neizmenyaemaya_karta)"},{"name":"ReadonlySet<T> (неизменяемое множество)","path":"ReadonlySet<T>_(neizmenyaemoe_mnojestvo)"}]},{"name":"Синтаксические конструкции и операторы","path":"Sintaksicheskie_konstrukcii_i_operatory","sections":[{"name":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"Operatory_prisvaivaniya_korotkogo_zamykaniya_(&&=,||=,&&=)"},{"name":"Операнды для delete должны быть необязательными","path":"Operandy_dlya_delete_doljny_byt_neobyazatelnymi"},{"name":"Объявление переменных 'необязательными' при деструктуризации массивоподобных объектов","path":"Obyavlenie_peremennyh_'neobyazatelnymi'_pri_destrukturizacii_massivopodobnyh_obektov"},{"name":"Модификатор abstract для описания типа конструктора","path":"Modifikator_abstract_dlya_opisaniya_tipa_konstruktora"}]},{"name":"Типизированный React","path":"Tipizirovannyi_React","sections":[{"name":"Расширение .tsx","path":"Rasshirenie_.tsx"}]},{"name":"Функциональные компоненты","path":"Funkcionalnye_komponenty","sections":[{"name":"Определение компонента как Function Declaration","path":"Opredelenie_komponenta_kak_Function_Declaration"},{"name":"Определение компонента как Function Expression","path":"Opredelenie_komponenta_kak_Function_Expression"}]},{"name":"Классовые компоненты","path":"Klassovye_komponenty","sections":[{"name":"Производные от Component<P, S, SS>","path":"Proizvodnye_ot_Component<P,S,SS>"},{"name":"Производные от PureComponent<Props, State, Snapshot>","path":"Proizvodnye_ot_PureComponent<Props,State,Snapshot>"}]},{"name":"Универсальные компоненты","path":"Universalnye_komponenty","sections":[{"name":"Обобщенные компоненты (Generics Component)","path":"Obobshchennye_komponenty_(Generics_Component)"}]},{"name":"Типизированные хуки","path":"Tipizirovannye_huki","sections":[{"name":"Предопределенные хуки - useState<T>()","path":"Predopredelennye_huki_-_useState<T>()"},{"name":"Предопределенные хуки - useEffect() и useLayoutEffect()","path":"Predopredelennye_huki_-_useEffect()_i_useLayoutEffect()"},{"name":"Предопределенные хуки - useContext<T>()","path":"Predopredelennye_huki_-_useContext<T>()"},{"name":"Предопределенные хуки - useReducer<R>()","path":"Predopredelennye_huki_-_useReducer<R>()"},{"name":"Предопределенные хуки - useCallback<T>()","path":"Predopredelennye_huki_-_useCallback<T>()"},{"name":"Предопределенные хуки - useRef<T>()","path":"Predopredelennye_huki_-_useRef<T>()"},{"name":"Предопределенные хуки - useImperativeHandle<T, R>()","path":"Predopredelennye_huki_-_useImperativeHandle<T,R>()"},{"name":"Предопределенные хуки - useMemo<T>()","path":"Predopredelennye_huki_-_useMemo<T>()"},{"name":"Предопределенные хуки - useDebugValue<T>()","path":"Predopredelennye_huki_-_useDebugValue<T>()"},{"name":"Пользовательский хук","path":"Polzovatelskii_huk"}]},{"name":"Контекст (Context)","path":"Kontekst_(Context)","sections":[{"name":"Определение контекста","path":"Opredelenie_konteksta"}]},{"name":"HOC (Higher-Order Components)","path":"HOC_(Higher-Order_Components)","sections":[{"name":"Определение hoc","path":"Opredelenie_hoc"},{"name":"Определение hoc на основе функционального компонента","path":"Opredelenie_hoc_na_osnove_funkcionalnogo_komponenta"},{"name":"Определение hoc на основе классового компонента","path":"Opredelenie_hoc_na_osnove_klassovogo_komponenta"}]},{"name":"Пространства имен (namespace) и модули (module)","path":"Prostranstva_imen_(namespace)_i_moduli_(module)","sections":[{"name":"Namespace и module — предназначение","path":"Namespace_i_module_—_prednaznachenie"},{"name":"Namespace - определение","path":"Namespace_-_opredelenie"},{"name":"Модули (export, import) — определение","path":"Moduli_(export,import)_—_opredelenie"},{"name":"Конфигурирование проекта","path":"Konfigurirovanie_proekta"}]},{"name":"Настройка рабочего окружения","path":"Nastroika_rabochego_okrujeniya","sections":[{"name":"Настройка рабочего окружения","path":"Nastroika_rabochego_okrujeniya"},{"name":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"Sborka_proekta_s_pomoshchu_tsc_(TypeScript_compiler)"}]},{"name":"Сборка с использованием ссылок на проекты","path":"Sborka_s_ispolzovaniem_ssylok_na_proekty","sections":[{"name":"Ссылки на проекты","path":"Ssylki_na_proekty"}]},{"name":"Декларации","path":"Deklaracii","sections":[{"name":"Что такое декларация (Declaration)","path":"Chto_takoe_deklaraciya_(Declaration)"},{"name":"Установка деклараций с помощью @types","path":"Ustanovka_deklaracii_s_pomoshchu_@types"},{"name":"Подготовка к созданию декларации","path":"Podgotovka_k_sozdaniu_deklaracii"},{"name":"Разновидности деклараций","path":"Raznovidnosti_deklaracii"},{"name":"Декларации и область видимости","path":"Deklaracii_i_oblast_vidimosti"},{"name":"Декларации для библиотек с одной точкой входа","path":"Deklaracii_dlya_bibliotek_s_odnoi_tochkoi_vhoda"},{"name":"Декларации для библиотек с множеством точек входа","path":"Deklaracii_dlya_bibliotek_s_mnojestvom_tochek_vhoda"},{"name":"Создание деклараций вручную","path":"Sozdanie_deklaracii_vruchnuu"},{"name":"Директива с тройным слешем (triple-slash directives)","path":"Direktiva_s_troinym_sleshem_(triple-slash_directives)"},{"name":"Импортирование декларации (import)","path":"Importirovanie_deklaracii_(import)"}]},{"name":"Публикация TypeScript","path":"Publikaciya_TypeScript","sections":[{"name":"Публикация","path":"Publikaciya"}]},{"name":"Опции компилятора","path":"Opcii_kompilyatora","sections":[{"name":"strict","path":"strict"},{"name":"suppressExcessPropertyErrors","path":"suppressExcessPropertyErrors"},{"name":"suppressImplicitAnyIndexErrors","path":"suppressImplicitAnyIndexErrors"},{"name":"noImplicitAny","path":"noImplicitAny"},{"name":"checkJs","path":"checkJs"},{"name":"JSX","path":"JSX"},{"name":"jsxFactory","path":"jsxFactory"},{"name":"target (t)","path":"target_(t)"},{"name":"extends","path":"extends"},{"name":"alwaysStrict","path":"alwaysStrict"},{"name":"strictNullChecks","path":"strictNullChecks"},{"name":"stripInternal","path":"stripInternal"},{"name":"noImplicitThis","path":"noImplicitThis"},{"name":"noImplicitUseStrict","path":"noImplicitUseStrict"},{"name":"baseUrl","path":"baseUrl"},{"name":"paths","path":"paths"},{"name":"rootDir","path":"rootDir"},{"name":"rootDirs","path":"rootDirs"},{"name":"traceResolution","path":"traceResolution"},{"name":"lib","path":"lib"},{"name":"noLib","path":"noLib"},{"name":"noResolve","path":"noResolve"},{"name":"noStrictGenericChecks","path":"noStrictGenericChecks"},{"name":"preserveConstEnums","path":"preserveConstEnums"},{"name":"removeComments","path":"removeComments"},{"name":"noUnusedLocals","path":"noUnusedLocals"},{"name":"noUnusedParameters","path":"noUnusedParameters"},{"name":"skipLibCheck","path":"skipLibCheck"},{"name":"declarationDir","path":"declarationDir"},{"name":"types","path":"types"},{"name":"typeRoots","path":"typeRoots"},{"name":"allowUnusedLabels","path":"allowUnusedLabels"},{"name":"noImplicitReturns","path":"noImplicitReturns"},{"name":"noFallthroughCasesInSwitch","path":"noFallthroughCasesInSwitch"},{"name":"outFile","path":"outFile"},{"name":"allowSyntheticDefaultImports","path":"allowSyntheticDefaultImports"},{"name":"allowUnreachableCode","path":"allowUnreachableCode"},{"name":"allowJs","path":"allowJs"},{"name":"reactNamespace","path":"reactNamespace"},{"name":"pretty","path":"pretty"},{"name":"moduleResolution","path":"moduleResolution"},{"name":"exclude","path":"exclude"},{"name":"noEmitHelpers","path":"noEmitHelpers"},{"name":"newLine","path":"newLine"},{"name":"inlineSourceMap","path":"inlineSourceMap"},{"name":"inlineSources","path":"inlineSources"},{"name":"noEmitOnError","path":"noEmitOnError"},{"name":"noEmit","path":"noEmit"},{"name":"charset","path":"charset"},{"name":"diagnostics","path":"diagnostics"},{"name":"declaration","path":"declaration"},{"name":"downlevelIteration","path":"downlevelIteration"},{"name":"emitBOM","path":"emitBOM"},{"name":"emitDecoratorMetadata","path":"emitDecoratorMetadata"},{"name":"forceConsistentCasingInFileNames","path":"forceConsistentCasingInFileNames"},{"name":"help (h)","path":"help_(h)"},{"name":"importHelpers","path":"importHelpers"},{"name":"isolatedModules","path":"isolatedModules"},{"name":"listEmittedFiles","path":"listEmittedFiles"},{"name":"listFiles","path":"listFiles"},{"name":"sourceRoot","path":"sourceRoot"},{"name":"mapRoot","path":"mapRoot"},{"name":"maxNodeModuleJsDepth","path":"maxNodeModuleJsDepth"},{"name":"project (p)","path":"project_(p)"},{"name":"init","path":"init"},{"name":"version (v)","path":"version_(v)"},{"name":"watch (w)","path":"watch_(w)"},{"name":"preserveSymlinks","path":"preserveSymlinks"},{"name":"strictFunctionTypes","path":"strictFunctionTypes"},{"name":"locale","path":"locale"},{"name":"strinctPropertyInitialization","path":"strinctPropertyInitialization"},{"name":"esModuleInterop","path":"esModuleInterop"},{"name":"emitDeclarationsOnly","path":"emitDeclarationsOnly"},{"name":"resolveJsonModule","path":"resolveJsonModule"},{"name":"declarationMap","path":"declarationMap"},{"name":"strictBindCallApply","path":"strictBindCallApply"},{"name":"showConfig","path":"showConfig"},{"name":"build","path":"build"},{"name":"verbose","path":"verbose"},{"name":"dry","path":"dry"},{"name":"clean","path":"clean"},{"name":"force","path":"force"},{"name":"incremental","path":"incremental"},{"name":"tsBuildInfoFile","path":"tsBuildInfoFile"},{"name":"allowUmdGlobalAccess","path":"allowUmdGlobalAccess"},{"name":"disableSourceOfProjectReferenceRedirect","path":"disableSourceOfProjectReferenceRedirect"},{"name":"useDefineForClassFields","path":"useDefineForClassFields"},{"name":"importsNotUsedAsValues","path":"importsNotUsedAsValues"},{"name":"assumeChangesOnlyAffectDirectDependencies","path":"assumeChangesOnlyAffectDirectDependencies"},{"name":"watchFile","path":"watchFile"},{"name":"watchDirectory","path":"watchDirectory"},{"name":"fallbackPolling","path":"fallbackPolling"},{"name":"synchronousWatchDirectory","path":"synchronousWatchDirectory"},{"name":"noUncheckedIndexedAccess","path":"noUncheckedIndexedAccess"},{"name":"noPropertyAccessFromIndexSignature","path":"noPropertyAccessFromIndexSignature"},{"name":"explainFiles","path":"explainFiles"}]}]}},"staticQueryHashes":["408059355","63159454"]}