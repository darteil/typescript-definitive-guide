{"componentChunkName":"component---src-page-templates-book-page-book-page-provider-tsx","path":"/book/chapters/Funkcionalnye_komponenty","result":{"pageContext":{"localization":{"lang":"ru","title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи.","appNavigation":[{"id":"index","path":"/","name":"Главная"},{"id":"book-contents","path":"/book/chapters","name":"Оглавление"},{"id":"what-is-new-contents","path":"/what-is-new","name":"Что нового?"},{"id":"pdf","path":"/pdf","name":"PDF Версия"}],"notification":{"behaviorNotification":{"copyLink":"Ссылка скопирована!"}},"layouts":{"shared":{"informers":{"donateInformer":{"minBanner":{"label":"Хочешь поддержать проект финансово?","buttons":{"yes":"Да, хочу! Узнать подробнее...","no":"Нет. Закрыть окно."}},"maxBanner":{"html":{"__html":"Чтобы <b>контент</b> приносил <b>максимальную пользу</b> его <b>необходимо</b> постоянно <b>совершенствовать</b> и <b>адаптировать</b>\n        под каждую новую версию <i>TypeScript</i>. Это отнимает <b>много времени</b> и без Вашей, даже <b>незначительно\n        финансовой</b>, поддержки практически <b>невозможно</b>. Помогая проекту вы прежде всего принимаете <b>участие</b> в\n        <b>развитии</b> профессионального уровня ваших <b>друзей</b>, <b>коллег</b>, <b>подчиненных</b>. Выпусти желание\n        сделать свой мир лучше. <b>Сделай контент для будущих специалистов ещё качественней и доступней!</b>"},"href":"#"}},"watchWithTelegramInformer":{"text":["Хочешь поддерживать свои знания в актуальном состоянии?","Тогда подписывайся на Telegram канал и узнавай обо всех изменениях!"],"subscribeButton":{"label":"Подписаться"}},"contentLevelUpInformer":{"text":"Кажется непонятным и слишком сложным? Чего-то не хватает? Расскажи об этом! Помоги сделать контент более доступным для следующих поколений!","buttons":[{"label":"Сообщить на Github","href":""}]}},"links":{"telegram":"#"},"appContent":{"contentNav":{"prevButton":{"label":"Назад"},"nextButton":{"label":"Вперед"}}},"appHeader":{"navToggleButton":{"tooltips":{"open":["Открыть боковое","меню"],"close":["Закрыть боковое","меню"]}},"appMenu":{"pdfButton":{"href":"#","tooltip":["Скачать","PDF версию"],"label":"Скачать PDF версию"},"telegramButton":{"href":"https://t.me/nauchikus","tooltip":["Следить за","изменениями в","Telegram"],"label":"Следить за изменениями в Telegram"},"githubButton":{"href":"https://github.com/nauchikus/typescript-definitive-guide","tooltip":["Посетить проект на","Github"],"label":"Посетить проект на Github"}},"donateDropdown":{"href":"https://yasobe.ru/na/typescript_definitive_guide","toggleButton":{"label":["Поддержать","финансово"]},"content":{"title":"Сделай контент для будущих поколений ещё качественней и доступней!","subtitle":{"__html":"Контент требует постоянного совершенствования и адаптации под каждую новую версию\nязыка TypeScript.\nЭто отнимает много времени и без Вашей, даже незначительно финансовой, поддержки практически\nневозможно.\nПрими участие в развитии профессионального уровня своих друзей, коллег, подчиненных. Встань на\nсторону небезразличных!"}}},"appSearch":{"inputPlaceholder":"Я ищу...","submitButton":{"ariaLabel":"Отправить"}}},"pdf":{"downloadPdfBookButton":{"title":"Скачать PDF Версию","href":"pdf/TypeScript Подробное Руководство.pdf"}}}},"pages":{"index":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"appDescription":"Книга и документация в одном","subtitleAll":["TypeScript в деталях","TypeScript крупным планом","TypeScript под микроскопом","TypeScript со всех сторон"]}},"book__chapters":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"},"collapseTocButton":{"tooltip":{"openState":"Открыть","closeState":"Закрыть"}}},"secondaryContentBar":{"label":"Оглавление","tocFilterButton":{"tooltip":"Отфильтровать на основе разделов"},"tocCollapseAllButton":{"tooltip":{"openState":"Раскрыть все","closeState":"Закрыть все"}}},"asideLayout":{"tagBarLabel":"Тематические разделы","tagBar":{"cleanFilterButton":"Все разделы"}}}},"book__chapter":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"secondaryContentBar":{"editOnGithubButton":{"tooltip":"Редактировать на Github"}}}},"what-is-new__toc":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"primaryContentBar":{"label":"История нововведений"},"tocItem":{"copyLinkToBufferButton":{"tooltip":"Скопировать ссылку в буфер обмена"}}}},"not-found":{"metadata":{"title":"TypeScript - в деталях","description":"Книга и документация по языку TypeScript, которая шаг за шагом раскрывает весь его потенциал не оставляя без внимания ни одной мелочи."},"gui":{"notFound_404":{"status":"404","title":"Страница не найдена :("}}},"pdf":{"metadata":{"title":"TypeScript - в деталях","description":"Бесплатная pdf книга на русском по языку TypeScript."},"gui":{"title":"TypeScript Подробное Руководство","subtitle":"PDF Версия"}}}},"pageContentData":{"title":"Функциональные компоненты","section":"React","path":"funkcionalnye komponenty","subtitles":[{"subtitle":"Определение компонента как Function Declaration","path":"funkcionalnye komponenty#opredelenie komponenta kak function declaration"},{"subtitle":"Определение компонента как Function Expression","path":"funkcionalnye komponenty#opredelenie komponenta kak function expression"}],"html":"<section class=\"content__section\" id=\"\"><h1 class=\"content__heading_1 main-title\">\n    <button class=\"content__button_copy-to-buffer\" path=\"\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Функциональные компоненты</span></h1><p class=\"content__paragraph\">Поскольку создавать <em>React</em> приложения рекомендуется на основе функциональных компонентов, то именно с них и начнется наше погружение в типизированные <code>.tsx</code> конструкции.</p><p class=\"content__paragraph\">Всем известно, что <em>React</em> компоненты, обозначаемые как <em>функциональные</em>, являются обычными функциями. И как все функции в <em>JavaScript</em>, они также могут быть определены двумя способами — в виде обычной функции (<em>Function Declaration</em>) и в виде функционального выражения (<em>Function Expression</em>), таящего один неочевидный нюанс, который подробно будет рассмотрен по ходу знакомства с ним.</p></section>\n<section class=\"content__section\" id=\"Opredelenie_komponenta_kak_Function_Declaration\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"Opredelenie_komponenta_kak_Function_Declaration\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Определение компонента как Function Declaration</span></h2><p class=\"content__paragraph\">Факт, что функциональный компонент, является обычной функцией, предполагает необходимость в типизировании её сигнатуры или точнее её параметров, так как указание типа возвращаемого значения не просто можно, а даже рекомендуется опустить, возложив эту работу на вывод типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">      <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**[1] */</span> \n<span class=\"token keyword\">function</span> <span class=\"token function\">Timer</span><span class=\"token punctuation\">(</span><span class=\"token comment\">/**[2] */</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">/**[3] */</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Is Timer<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Timer<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [1] функциональный компонент\n * определенный как Function Declaration.\n * [2] отсутствующие параметры.\n * [3] отсутствие явного указания типа\n * возвращаемого типа.\n * [0] все компоненты обязаны импортировать\n * пространство имен React.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Также необходимо всегда помнить, что независимо от того используется пространство имен <code>React</code> непосредственно или нет, модули определяющие <em>React</em> компоненты обязаны его импортировать. В противном случае компилятор напомнит об этом с помощью ошибки.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/**\n * Error ->\n * 'React' refers to a UMD global, but the current file is a module.\n * Consider adding an import instead.\n */</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>span<span class=\"token operator\">></span><span class=\"token constant\">I</span> ❤️ TypeScript<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Ok -> добавлен импорт пространства имен React\n */</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Message</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>span<span class=\"token operator\">></span><span class=\"token constant\">I</span> ❤️ TypeScript<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">При определении первого параметра функционального компонента <code>props</code> появляется потребность в типе описывающем их. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n  message<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[1] */</span>\n  duration<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[2] */</span>\n<span class=\"token punctuation\">}</span>\n\n                                            <span class=\"token comment\">/**[3] */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Timer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>duration<span class=\"token punctuation\">,</span> message <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">Done!</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] определения типа интерфейса\n * который будет указан в аннотации\n * первого параметра функционального\n * компонента [3] и чье описание \n * включает необязательное поле message [1]\n *  и обязательного duration [2] \n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Поскольку идеология <em>React</em> подразумевает <em>прокидывание пропсов</em> из одного компонента в другой, то компоненту выступающему в роли провайдера помимо своих пропсов, необходимо описывать пропсы своих детей. В случаях, когда в проброске нуждаются только несколько значений принадлежащих к типам из системы типов <em>TypeScript</em>, декларирование их в пропсах провайдера не будет выглядеть удручающе.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// file Informer.tsx</span>\n\n<span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n    message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] описание пропсов компонента Informer\n */</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Informer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n\n\n<span class=\"token comment\">// file InformerDecorator.tsx</span>\n\n<span class=\"token keyword\">import</span> Informer <span class=\"token keyword\">from</span> <span class=\"token string\">\"./Informer\"</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">Props</span> <span class=\"token punctuation\">{</span>\n    decor<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[1] */</span>\n    message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[2] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] описание пропсов компонента InformerDecorator\n * [1] значение предназначаемое непосредственно текущему компоненту\n * [2] значение предназначаемое компоненту Informer\n */</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">InformerDecorator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>decor<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>Informer message<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>message <span class=\"token operator\">+</span> decor<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Но если пробрасываемые пропсы представлены множеством значений, к тому же, частично или полностью принадлежат к пользовательским типам, то более целесообразно включить в описание типа пропсов компонента-провайдера, тип, описывающий пропсы компонента, которому они предназначаются. Поэтому тип описывающий пропсы желательно всегда экспортировать. Для того, что бы избежать коллизий именования типов представляющих пропсы, их идентификаторы необходимо конкретизировать, то есть давать более уникальные имена. Поэтому принято имени <code>Props</code> добавлять префикс идентичный названию самого компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// file Informer.tsx</span>\n\n<span class=\"token comment\">/**[0] */</span>           <span class=\"token comment\">/**[1] */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">InformerProps</span> <span class=\"token punctuation\">{</span>\n    message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] экспорт типа\n * [1] уточнение идентификатора (имени)\n */</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Informer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> InformerProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n\n\n<span class=\"token comment\">// file InformerDecorator.tsx</span>\n                    <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> Informer<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>InformerProps<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./Informer\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] импорт типа пропсов\n */</span>\n\n<span class=\"token comment\">/**[1] */</span>               <span class=\"token comment\">/**[2] */</span>                   <span class=\"token comment\">/**[3] */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">InformerDecoratorProps</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">InformerProps</span> <span class=\"token punctuation\">{</span>\n    decor<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/**[4] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [1] экспорт типа\n * [2] уточнение идентификатора (имени)\n * [3] расширение типа пропсов другого компонента\n * позволяет не дописывать необходимые ему поля [4]\n */</span>\n\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">InformerDecorator</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>decor<span class=\"token punctuation\">,</span> message<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> InformerDecoratorProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>Informer message<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>message <span class=\"token operator\">+</span> decor<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В случаях когда компонент-провайдер нуждается только в части пропсов определенных в типе представляющих их, ненужную часть можно исключить с помощью типа <code>Omit&#x3C;T, K></code> или <code>Exclude&#x3C;T, U></code>.</p><p class=\"content__paragraph\">Тем, кому ближе минимализм, может прийтись по душе подход с получением типа пропсов без его экспорта. </p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// @filename: Informer.tsx</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// InformerProps не экспортируется наружу</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">InformerProps</span> <span class=\"token punctuation\">{</span>\n    message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Informer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> InformerProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// @filename: InformerDecorator.tsx</span>\n\n                  <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> ComponentType <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/**[1] */</span>\n<span class=\"token keyword\">import</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Informer</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./Informer\"</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**[2] */</span>  <span class=\"token comment\">/**[3] */</span>        <span class=\"token comment\">/**[4] */</span>   <span class=\"token comment\">/**[5] */</span>   <span class=\"token comment\">/**[6] */</span><span class=\"token comment\">/**[7] */</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">GetProps<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token constant\">T</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">ComponentType<span class=\"token operator\">&lt;</span>infer Props<span class=\"token operator\">></span></span> <span class=\"token operator\">?</span> Props <span class=\"token operator\">:</span> <span class=\"token builtin\">unknown</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">/**[8] */</span>               <span class=\"token comment\">/**[9] */</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">InformerProps</span> <span class=\"token operator\">=</span> GetProps<span class=\"token operator\">&lt;</span><span class=\"token keyword\">typeof</span> Informer<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n                                                  <span class=\"token comment\">/**[10] */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">InformerDecoratorProps</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">InformerProps</span> <span class=\"token punctuation\">{</span>\n    decor<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] Импортируем обобщенный тип ComponentType&lt;Props>\n * представляющий объединение классового и функционального\n * компонента. [1] Импортируем как \"только тип\" функциональный\n * компонент Informer. [2] Определяем тип GetProps&lt;T> параметр типа\n * которого ожидает тип React компонента. Далее, с помощью механизма\n * определения типа на основе условия (условный тип) выясняем принадлежит\n * ли тип [3] T к React компоненту и в этот момент определяем переменную\n * infer Props [5], которая и будет представлять тип пропсов компонент T.\n * Если условие верно, то возвращаем тип [6] Props, иначе unknown.\n * [8] С помощью типа GetProps, на основе типа Informer, полученного\n * с помощью запроса типа [9], определяем новый  тип InformerProps,\n * который в дальнейшем используем по назначению.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Подобный способ будет не заменим при работе со сторонними библиотеками <em>React</em> компонентов, которые не имеют экспорты типов описывающих свои пропсы.</p><p class=\"content__paragraph\">Не будет лишним напомнить, что при помощи модификатора <code>readonly</code> не удастся избежать изменений переменных ссылки на которые были получены с помощью механизма деструктуризации.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">InformerProps</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">/**[0] */</span>\n    <span class=\"token keyword\">readonly</span> message<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n                                            <span class=\"token comment\">/**[1] */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Informer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span> <span class=\"token operator\">:</span> Readonly<span class=\"token operator\">&lt;</span>InformerProps<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    message <span class=\"token operator\">=</span> <span class=\"token string\">'new value'</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[2] */</span>\n\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>message<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] добавление модификатора readonly вручную,\n * а затем ещё тоже самое с помощью тип Readonly&lt;T> [1]\n * и тем не менее переменная message изменяема [2].\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Такое поведение является причиной того, что деструктурированные идентификаторы являются определением новой переменной, а переменные не могут иметь модификатор <code>readonly</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                  <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">let</span> o<span class=\"token operator\">:</span> Readonly<span class=\"token operator\">&lt;</span><span class=\"token punctuation\">{</span>f<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>f<span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\no<span class=\"token punctuation\">.</span>f <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error -> [1]</span>\n\n<span class=\"token keyword\">let</span> <span class=\"token punctuation\">{</span>f<span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> o<span class=\"token punctuation\">;</span>\nf <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok -> [2]</span>\n\n<span class=\"token comment\">/**\n * Определение переменной o с типом инлайн интерфейса [0]\n * поля которого модифицированный с помощью типа Readonly&lt;T>.\n * При попытке изменить член o.f с модификатором readonly\n * возникает ошибка [1] ->\n * Cannot assign to 'f' because it is a read-only property.\n * Чего не происходит при изменении переменной определенной\n * в процессе деструктуризации.\n * \n * Механизм деструктуризации предполагает создание новой\n * переменной со значением одноименного члена объекта указанного\n * в качестве правого операнда выражения.\n * Выражение let {f} = o; эквивалентно выражению let f = o.f;\n * В этом случае создается новая переменная тип которой устанавливается\n * выводом типов. А вот модификатор readonly не применим к переменным.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">При необходимости декларирования <code>children</code> можно выбрать несколько путей. Первый из них подразумевает использование обобщенного типа <code>PropsWithChildren&#x3C;P></code> ожидающего в качестве аргумента типа тип представляющий пропсы. Данный тип определяет <code>children</code> как необязательное поле принадлежащее к <code>ReactNode</code>. При отсутствии продуманного плана насчёт <code>children</code> или необходимости их принадлежности к любому допустимому типу, данный тип будет как нельзя к месту.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                    <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>PropsWithChildren<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">LabelProps</span> <span class=\"token punctuation\">{</span>\n\n<span class=\"token punctuation\">}</span>\n\n                                                <span class=\"token comment\">/**[1] */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> PropsWithChildren<span class=\"token operator\">&lt;</span>LabelProps<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>span<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] импорт типа PropsWithChildren&lt;T>\n * для указания его в аннотации типа параметров [1].\n */</span>\n\n\n<span class=\"token operator\">&lt;</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token string\">\"label\"</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// string as children -> Ok [2]</span>\n<span class=\"token operator\">&lt;</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token number\">1000</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// number as children -> Ok [3]</span>\n<span class=\"token operator\">&lt;</span>Label<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// undefined as children -> Ok [4]</span>\n\n <span class=\"token comment\">/**\n  * При создании экземпляров компонента Label\n  * допустимо указывать в качестве children\n  * как строку [2], так и числа [3] и кроме\n  * того не указывать значения вовсе [4]\n  */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если логика компонента предполагает обязательную установку <code>children</code> или уточнение типа к которому они принадлежат, то появляется необходимость их непосредственной декларации в типе представляющем пропсы этого компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/**\n * [0] children определены как \n * обязательное принадлежащее к\n * типу string поле.\n */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">LabelProps</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[0] */</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> LabelProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>span<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token operator\">&lt;</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">label</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\n<span class=\"token operator\">&lt;</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">{</span><span class=\"token number\">1000</span><span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error -> number не совместим со string</span>\n<span class=\"token operator\">&lt;</span>Label<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error -> children обязательны</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Может показаться, что конкретизация типа <code>children</code> будет полезна при создании собственных <code>ui</code> компонентов. К примеру при создании компонента <code>List</code> выполняющего отрисовку элемента <code>ul</code>, было бы здорово определить <code>children</code>, как массив компонентов <code>ListItem</code> отрисовывающих элемент <code>li</code>.</p><p class=\"content__paragraph\">Для этого понадобится импортировать обобщенный тип <code>ReactElement&#x3C;P, T></code>, первый параметр типа которого ожидает тип пропсов, а второй строку или конструктор компонента для указания его в качестве типа поля <code>type</code> необходимого для идентификации. По факту тип <code>ReactElement&#x3C;P, T></code> представляет экземпляр любого компонента в системе типов <em>React</em>. После определения компонентов <code>List</code> и <code>ListItem</code>, для первого нам понадобится переопределить поле <code>children</code>, указав ему тип <code>ReactElement&#x3C;ListItemProps></code>, что буквально означает — экземпляр компонента, пропсы которого принадлежат к типу указанному в качестве первого аргумента типа.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                  <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> ReactElement<span class=\"token punctuation\">,</span> ReactNode <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] импорт типа представляющего\n * экземпляр любого компонента.\n */</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ListItemProps</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> ReactNode<span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[1] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [1] для примера определим тип children\n * как ReactNode представляющего любой\n * допустимый тип.\n */</span>\n\n <span class=\"token keyword\">function</span> <span class=\"token function\">ListItem</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> ListItemProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>li<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>li<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n\n\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ListProps</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> ReactElement<span class=\"token operator\">&lt;</span>ListItemProps<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[2] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [2] при определении children\n * указываем тип ReactElement&lt;ListItemProps>\n *, что стоит понимать как - экземпляр компонента\n * пропсы которого совместимы с типом ListItemProps.\n */</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">List</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> ListProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>ul<span class=\"token operator\">></span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ul<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**[3] */</span>\n<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>ListItem<span class=\"token operator\">></span>first<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ListItem<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>List<span class=\"token operator\">></span>\n\n<span class=\"token comment\">/**\n * [3] создаем экземпляр List\n * и указываем ему в качестве children\n * один экземпляр ListItem.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если кажется просто, то не стоит сомневаться, оно так и есть. Совершенно ничего сложного. Единственное стоит уточнить два важных момента.</p><p class=\"content__paragraph\">Первый момент заключается в том, что конкретизация типа <code>children</code> для <em>React</em> элементов не работает. Проще говоря, если определить новый компонент <code>Label</code> и указать ему в качестве пропсов тип определяющий единственное поле <code>type</code>, то его экземпляр без возникновения ошибки можно будет указать в качестве <code>children</code> компоненту <code>List</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ListItemProps</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> <span class=\"token builtin\">string</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] оставляем тип пропсов,\n * но для упрощения удаляем компонент\n * нуждающийся в нем.\n */</span>\n\n<span class=\"token comment\">/**[1] */</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">LabelProps</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token string\">'danger'</span> <span class=\"token operator\">|</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">error</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n    children<span class=\"token operator\">:</span> ReactNode<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**[1] */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Label</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">}</span><span class=\"token operator\">:</span> LabelProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>span className<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token keyword\">type</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [1] определяем компонент Label\n * и описываем его пропсы.\n */</span>\n\n\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">ListProps</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> ReactElement<span class=\"token operator\">&lt;</span>ListItemProps<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[2] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * Тип children по прежнему указан\n * как ReactElement&lt;ListItemProps>.\n */</span>\n\n<span class=\"token comment\">// компонент List удален для упрощения</span>\n\n<span class=\"token comment\">/**[3] */</span>\n<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>Label <span class=\"token keyword\">type</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token string\">'danger'</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>Hello World<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Label<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>List<span class=\"token operator\">></span>\n\n<span class=\"token comment\">/**\n * [3] несмотря на то, что в компоненте List\n * тип children обозначен как ReactElement&lt;ListItemProps>\n * вместо ожидаемого экземпляра без возникновения\n * ошибки устанавливается тип ReactElement&lt;LabelProps>.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Всё дело в том, что экземпляр компонента представляется типом <code>Element</code> из пространства имен <em>JSX</em>, является производным от типа <code>ReactElement&#x3C;P, T></code>. Кроме того, при расширении, своему базовому классу, в качестве аргументов типа, он устанавливает <code>any</code> - <code>Element extends ReactElement&#x3C;any, any></code>. Это в свою очередь означает?, что любые экземпляры компонентов будут совместимы с любыми типами <code>ReactElement&#x3C;P, T></code>, что делает уточнение типа бессмысленным.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> listItem <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>ListItem<span class=\"token operator\">></span>first<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ListItem<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let listItem: JSX.Element</span>\n<span class=\"token keyword\">let</span> label <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>Label <span class=\"token keyword\">type</span><span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token string\">'danger'</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span>label<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Label<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// let label: JSX.Element</span>\n\n<span class=\"token comment\">/**\n * Поскольку оба экземпляра принадлежат\n * к типу JSX.Element который в свою очередь\n * является производным от типа ReactElement&lt;any, any>,\n *, то любой экземпляр будет совместим с любым типом ReactElement&lt;P, T>.\n */</span>\n\n <span class=\"token keyword\">let</span> v0<span class=\"token operator\">:</span> ReactElement<span class=\"token operator\">&lt;</span>ListItemProps<span class=\"token operator\">></span> <span class=\"token operator\">=</span> label<span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">let</span> v1<span class=\"token operator\">:</span> ReactElement<span class=\"token operator\">&lt;</span>LabelProps<span class=\"token operator\">></span> <span class=\"token operator\">=</span> listItem<span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\"> Кроме этого, <code>ReactElement&#x3C;P, T></code> совместим не только с экземплярами компонентов, но и <em>React</em> элементов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">let</span> v<span class=\"token operator\">:</span> ReactElement<span class=\"token operator\">&lt;</span>ListItemProps<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token operator\">&lt;</span>span<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Это, как уже было сказано, делает конкретизацию <code>children</code>, для экземпляров <em>React</em> компонентов и элементов, бессмысленной. Остается надеяться, что это исправят.</p><p class=\"content__paragraph\">Второй неочевидный момент состоит в том, что при текущей постановке, в случае необходимости указать в качестве <code>children</code> множество экземпляров <code>ListItem</code>, возникнет ошибка.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ListProps</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> ReactElement<span class=\"token operator\">&lt;</span>ListItemProps<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[0] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**[1] */</span>\n<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>ListItem<span class=\"token operator\">></span>first<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ListItem<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>ListItem<span class=\"token operator\">></span>second<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ListItem<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>List<span class=\"token operator\">></span>\n\n<span class=\"token comment\">/**\n * [0] тип указан как единственный\n * экземпляр компонента. поэтому при\n * установке множества экземпляров [1]\n * возникает ошибка.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Для разрешения подобного случая необходимо указать тип <code>children</code> как объединение (<code>Union</code>) определяемое типами представляющих как единственный экземпляр <code>ReactElement&#x3C;ListItemProps></code> так и множество, а если быть конкретнее, то массив экземпляров <code>ReactElement&#x3C;ListItemProps>[]</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ListProps</span> <span class=\"token punctuation\">{</span>\n    children<span class=\"token operator\">:</span> ReactElement<span class=\"token operator\">&lt;</span>ListItemProps<span class=\"token operator\">></span> <span class=\"token operator\">|</span> ReactElement<span class=\"token operator\">&lt;</span>ListItemProps<span class=\"token operator\">></span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[0] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**[1] */</span>\n<span class=\"token operator\">&lt;</span>List<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>ListItem<span class=\"token operator\">></span>first<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ListItem<span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span>ListItem<span class=\"token operator\">></span>second<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>ListItem<span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>List<span class=\"token operator\">></span>\n\n<span class=\"token comment\">/**\n * [0] указание в качестве типа children\n * объединение предполагающее как единственный\n * экземпляр так и множество, ошибка [1] не возникает.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Ввиду того, что тема касающаяся первого параметра функционального компонента обозначаемого пропсами, себя исчерпала, пришло время рассмотреть его второй, нечасто используемый, параметр, обозначаемый как <em>реф</em> и предназначенный для передачи ссылки на текущий компонент. Для большего понимания этого механизма необходимо начать его рассмотрение из далека. Но прежде стоит уточнить два момента. Во-первых, тему посвященную рефам стоит начать с напоминания, что они делятся на два вида. Первый вид предназначен для получения ссылок на <em>React элементы</em>, а второй на <em>React компоненты</em>. Так вот второй параметр функционального компонента предназначен для установления рефы на себя самого, тио есть на компонент. Во вторых, при рассмотрении механизма посвященного рефам, применяются хуки, чья логика работы будет затронута лишь поверхностно, поскольку впереди ожидает целая глава посвященная их подробному рассмотрению.</p><p class=\"content__paragraph\">Представьте сценарий при котором форма должна перейти в начальное состояние путем вызова нативного метода <code>reset()</code>, что потребует получения на нее ссылки с помощью объекта рефы создаваемого хуком <code>useRef()</code>.</p><p class=\"content__paragraph\">Для начала необходимо с помощью универсальной функции <code>useRef()</code> создать объект рефы и присвоить ссылку на него переменной, которую в дальнейшем установить элементу формы. Сразу стоит обратить внимание, что декларации <em>React</em> элементов содержат устаревшие типы в аннотации поля <code>ref</code>. Это непременно приведет к возникновению ошибки при установлении объекта рефы. Чтобы этого избежать, необходимо явным образом, при определении объекта рефы, преобразовать его к обобщенному типу <code>RefObject&#x3C;T></code>, которому в качестве аргумента типа установить тип нативного элемента, в данном случае <code>HTMLFormElement</code>. Также стоит сделать акцент на том, что необходимо именно преобразование. Указания аннотации типа переменной или передачи типа в качестве аргумента типа, хуку не поможет. Более детально поведение хука <code>useState()</code> рассматривается в главе посвященной предопределенным хукам.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> useRef<span class=\"token punctuation\">,</span> RefObject <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                   <span class=\"token comment\">/**[0]         [1]          [2] */</span>\n    <span class=\"token keyword\">let</span> formRef <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> RefObject<span class=\"token operator\">&lt;</span>HTMLFormElement<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    \n                 <span class=\"token comment\">/**[3] */</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>form ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>formRef<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>form<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * Создаваемый хуком объект рефы необходимо преобразовать в обобщенный тип\n * RefObject&lt;T> [1] в качестве аргумента которому требуется указать нативный тип\n * формы [2]. Если не произвести преобразования, то в момент установки объекта рефы форме [3]\n * возникнет ошибка, поскольку декларации описывающие React элементы содержат устаревший\n * тип в аннотации поля ref.\n * \n * БОЛЕЕ ПОДРОБНО В ТЕМЕ ПОСВЯЩЕННОЙ ХУКУ useRef()\n * \n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если появится необходимость задать форме первоначальное состояние извне компонента, то можно прибегнуть к механизму получения ссылки на сам компонент, или точнее на определяемый им объект выступающий в роли публичного <em>api</em>. Но, что бы стало возможным получить ссылку на функциональный компонент, его необходимо преобразовать с помощью универсальной функции <code>forwardRef&#x3C;R, P>()</code>, на которой сфокусируется дальнейшее повествование.</p><p class=\"content__paragraph\">По факту логика работы универсальной функции <code>forwardRef&#x3C;R, P>(render)</code> заключатся в проверке единственного параметра на принадлежность к функциональному типу у которой помимо первого параметра представляющего <code>props</code>, определен ещё и второй, представляющий <code>ref</code>. Данная функция обозначается как <code>render</code> и теоретически её можно считать функциональным компонентом с определением второго параметра предназначенного для установления рефы. В системе типов <em>React</em> функция <code>render</code> принадлежит к обобщенному функциональному типу <code>ForwardRefRenderFunction&#x3C;T, P></code> определяющего два параметра типа, первый из которых представляет тип рефы, а второй пропсов. Первый параметр функции <code>render</code> представляющий пропсы не таит в себе ничего необычного. В отличии от него, второй параметр представляющий рефу, требует детального рассмотрения, поскольку именно с ним связан один неочевидный момент.</p><p class=\"content__paragraph\">Дело в том, что рефы могут быть представлены как экземпляром объекта принадлежащего к типу <code>RefObject&#x3C;T></code> или полностью совместимым с ним <code>MutableRefObject&#x3C;T></code>, так и функцией <code>&#x3C;T>(instance: T) => void</code>. Учитывая этот факт, функция <code>render</code>, в аннотации типа второго параметра <code>ref</code>, просто вынуждена указать все эти типы в качестве <code>union</code>. Но сложность состоит в том, что определение объединения происходит непосредственно в аннотации типа параметра <code>ref</code>. Простыми словами система типов <em>React</em> не предусмотрела более удобного и короткого псевдонима типа представляющего рефу определяемую функциональным компонентом.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">interface</span> <span class=\"token class-name\">ForwardRefRenderFunction<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">P</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token operator\">></span></span> <span class=\"token punctuation\">{</span>\n                                       <span class=\"token comment\">/**                              [0]                              */</span>\n    <span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> PropsWithChildren<span class=\"token operator\">&lt;</span><span class=\"token constant\">P</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> ref<span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>instance<span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">|</span> MutableRefObject<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ReactElement <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] тип объединение определенный\n * непосредственно в аннотации типа.\n * Простыми словами он не имеет более\n * удобного короткого псевдонима.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Это означает, что функциональный компонент определенный как <em>Function Declaration</em> и указавший принадлежность второго параметра к типу, скажем <code>MutableRefObject&#x3C;T></code> не сможет пройти проверку на совместимость типов в качестве аргумента универсальной функции <code>forwardRef()</code>, даже если установить её аргументы типа. И причина тому контравариантность параметров функции при проверке на совместимость.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                    <span class=\"token comment\">/**[0]           [1] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> MutableRefObject<span class=\"token punctuation\">,</span> forwardRef <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">FormProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**[2] */</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">FormApi</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">reset</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [2] объявление типа описывающего доступное\n * api компонента.\n */</span>\n                               <span class=\"token comment\">/**[3]       [4]         [5] */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> FormProps<span class=\"token punctuation\">,</span> ref<span class=\"token operator\">:</span> MutableRefObject<span class=\"token operator\">&lt;</span>FormApi<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n        <span class=\"token comment\">/**[6]          [7]      [8]       [9]     [10] */</span>\n<span class=\"token keyword\">const</span> FormWithRef <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">forwardRef</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>FormApi<span class=\"token punctuation\">,</span> FormProps<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>Form <span class=\"token comment\">/**Error */</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> FormWithRef<span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[11] */</span>\n\n<span class=\"token comment\">/**\n * [0] импорт обобщенного типа MutableRefObject&lt;T>\n * который будет указан в аннотации типа [4] второго\n * параметра [3] функционального компонента предварительно\n * получив в качестве аргумента типа тип нативного dom\n * элемента HTMLDivElement [5].\n * \n * Несмотря на все принятые меры по типизации сигнатуры функционального\n * компонента Form избежать возникновения ошибки [10] при проверке на совместимость\n * в момент передачи в качестве аргумента универсальной функции forwardRef [7] не получится\n * даже при конкретизации с помощью аргументов функционального типа [8][9].\n * \n * [11] для экспорта функционального компонента определяющего второй параметр необходимо\n * сохранить результат выполнения функции forwardRef [6].\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Разрешить данную ситуацию можно несколькими способами. Первый заключается в явном преобразовании типа функционального компонента к типу <code>ForwardRefRenderFunction&#x3C;T, P></code> которому в качестве аргументов типа требуется указать необходимые типы. При этом отпадает нужда в указании аргументов типа непосредственно самой универсальной функции <code>forwardRef&#x3C;T, P>()</code>;</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                                                     <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> MutableRefObject<span class=\"token punctuation\">,</span> forwardRef<span class=\"token punctuation\">,</span> ForwardRefRenderFunction <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">FormProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">FormApi</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">reset</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> FormProps<span class=\"token punctuation\">,</span> ref<span class=\"token operator\">:</span> MutableRefObject<span class=\"token operator\">&lt;</span>FormApi<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n                        <span class=\"token comment\">/**[6]                          [7]       [8]        [9] */</span>\n<span class=\"token keyword\">const</span> FormWithRef <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>Form <span class=\"token keyword\">as</span> ForwardRefRenderFunction<span class=\"token operator\">&lt;</span>FormApi<span class=\"token punctuation\">,</span> FormProps<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> FormWithRef<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] импорт обобщенного функционального типа ForwardRefRenderFunction&lt;T, P>\n * к которому тип Form [7] будет преобразован с помощью оператора as, для\n * чего потребуется указать необходимые аргументы типа [8] [9]. При этом отпадает\n * потребность в установке аргументов непосредственно универсальной функции [6]\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Следующий способ заключается в получении типа представляющего рефу непосредственно из самого функционального типа <code>ForwardRefRenderFunction&#x3C;T, P></code>. Для необходимо указать в аннотации второго параметра функционального компонента обобщенный тип взятого у второго параметра функционального типа <code>ForwardRefRenderFunction&#x3C;T, P></code> при помощи типа <code>Parameters&#x3C;T></code> предназначенного для получения массива с типами соответствующих параметрам функции. Поскольку интересующий нас тип принадлежит второму параметру, то он будет доступен как элемент под индексом один. Кроме того, в указании аргументов типа универсальной функции <code>forwardRef&#x3C;T, P>()</code> нет необходимости, поскольку выводу типов достаточно описания сигнатуры функционального компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> forwardRef<span class=\"token punctuation\">,</span> ForwardRefRenderFunction <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">FormProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">FormApi</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">reset</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">/**[0][1]       [2]             [3]            [4] [5] */</span>\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Ref<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> Parameters<span class=\"token operator\">&lt;</span>ForwardRefRenderFunction<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n                                  <span class=\"token comment\">/**[6]   [7] */</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> FormProps<span class=\"token punctuation\">,</span> ref<span class=\"token operator\">:</span> Ref<span class=\"token operator\">&lt;</span>FormApi<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n                        <span class=\"token comment\">/**[8] */</span>\n<span class=\"token keyword\">const</span> FormWithRef <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>Form<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> FormWithRef<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * При помощи типа Parameters&lt;T> [2] получаем массив элементы которого\n * принадлежат к типам параметров функции представляемой типом\n * ForwardRefRenderFunction&lt;T, P> [3] которому в качестве первого аргумента\n * типа [4] устанавливаем параметр обобщенного псевдонима [1]. Таким образом\n * Ref&lt;T> ссылается на первый элемент массива [5] содержащего тип указанный в аннотации\n * второго параметра (ref). Определенный псевдоним указываем в аннотации\n * второго параметра функционального компонента [6] установив в качестве аргумента\n * типа тип нативного dom элемента [7]. При таком сценарии нет необходимости \n * конкретизировать типы при помощи аргументов типа универсальной функции\n * forwardRef&lt;T, P>() [8]. \n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Последнее на, что стоит обратить внимание, это обобщенный тип <code>ForwardRefExoticComponent&#x3C;P></code>, к которому принадлежит значение, возвращаемое из универсальной функции <code>forwardRef&#x3C;T, P>()</code>, и который указывать в явной форме нет никакой необходимости.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                                                              <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> forwardRef<span class=\"token punctuation\">,</span> ForwardRefRenderFunction<span class=\"token punctuation\">,</span> ForwardRefExoticComponent <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// ...</span>\n\n                            <span class=\"token comment\">/**[1]                [2] */</span>\n<span class=\"token keyword\">const</span> FormWithRef<span class=\"token operator\">:</span> ForwardRefExoticComponent<span class=\"token operator\">&lt;</span>FormProps<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>Form<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> FormWithRef<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] импорт обобщенного типа ForwardRefExoticComponent&lt;P>\n * который в качестве аргумента типа ожидает тип представляющий пропсы того\n * компонента [2] в аннотации типа которого указан [1]. Стоит заметить, \n * что указан он исключительно в образовательных целях.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">После того как функциональный компонент получит рефу, ему необходимо присвоить ей значение выступающее в качестве открытого <em>api</em>. Для этого необходимо прибегнуть к помощи хука <code>useImperativeHandle&#x3C;T, R>(ref: Ref&#x3C;T>, apiFactory() => R): void</code> подробное рассмотрение которого можно найти в теме посвященной предопределенным хукам. </p><p class=\"content__paragraph\">Для того, что бы ассоциировать <em>api</em> компонента с компонентной рефой при помощи хука <code>useImperativeHandle()</code>, ему необходимо передать её в качестве первого аргумента. После этого, компонентная рефа будет ассоциирована со значением возвращаемого из функции ожидаемой хуком в качестве второго параметра. Процесс переинициализации компонентной рефы будет выполняться всякий раз при изменении элементов массива ожидаемого в качестве третьего параметра данного хука. Также необходимо уточнить, что рефа создаваемая с помощью хука <code>useRef()</code> и предназначенная для ассоциации с функциональным компонентом, также нуждается в явном преобразовании к обобщенному типу <code>MutableRefObject&#x3C;T></code>, которому в качестве единственного аргумента типа будет установлен тип представляющий открытое <em>api</em> компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> forwardRef<span class=\"token punctuation\">,</span> ForwardRefRenderFunction<span class=\"token punctuation\">,</span> RefObject<span class=\"token punctuation\">,</span> useRef<span class=\"token punctuation\">,</span> useImperativeHandle<span class=\"token punctuation\">,</span> MutableRefObject <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">FormProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">interface</span> <span class=\"token class-name\">FormApi</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function-variable function\">reset</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token keyword\">void</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">type</span> <span class=\"token class-name\">Ref<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> Parameters<span class=\"token operator\">&lt;</span>ForwardRefRenderFunction<span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">>></span><span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> FormProps<span class=\"token punctuation\">,</span> ref<span class=\"token operator\">:</span> Ref<span class=\"token operator\">&lt;</span>FormApi<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token comment\">/**[0] */</span>\n    <span class=\"token keyword\">let</span> formRef <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> RefObject<span class=\"token operator\">&lt;</span>HTMLFormElement<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">/**[1]          [2]     [3] */</span>\n    <span class=\"token function\">useImperativeHandle</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function-variable function\">reset</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> formRef<span class=\"token punctuation\">.</span>current<span class=\"token operator\">?.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">/**[4] */</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>form ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>formRef<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>form<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] не забываем о необходимости явного преобразования.\n * Хук useImperativeHandle ожидает в качестве первого параметра\n * ссылку [1], в качестве второго фабричную функцию [3], которая\n * будет переопределять объект api каждый раз при изменении \n * элементов массива ожидаемого в качестве третьего параметра [4].\n *  \n */</span>\n\n<span class=\"token keyword\">const</span> FormWithRef <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>Form<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">App</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n                       <span class=\"token comment\">/**[5]         [6]        [7] */</span>\n    <span class=\"token keyword\">let</span> formRef <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> MutableRefObject<span class=\"token operator\">&lt;</span>FormApi<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n    \n    <span class=\"token comment\">/**[8] */</span>\n    formRef<span class=\"token punctuation\">.</span>current<span class=\"token operator\">?.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token comment\">/**[9] */</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>FormWithRef ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>formRef<span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * Необходимо помнить, что ссылка предназначенная\n * для ассоциации с функциональным компонентом\n * также требует явного преобразование [5] к обобщенному\n * типу MutableRefObject&lt;T> [6] которому в качестве аргумента\n * типа необходимо установить тип представляющий открытое api\n * компонента [7]. И после создания экземпляра компонента определенного\n * с помощью функции forwardRef [9] можно использовать его api через объект\n * рефы [8].\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В связи с тем, что функциональный компонент может определять только два параметра, пора перейти к рассмотрению следующего звена его сигнатуры — аннотации типа возвращаемого им значения. Для этого возвратимся к первоначальному, модифицированному с учетом пропсов, примеру функционального компонента у которого тип возвращаемого значения не указан явно, что в большинстве случаев является предпочтительней явного указания.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TimerProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Timer</span><span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> TimerProps<span class=\"token punctuation\">)</span> <span class=\"token comment\">/**[0] */</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Is Timer<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n\n<span class=\"token comment\">/**\n * [0] отсутствие явного указания типа\n * возвращаемого типа, которая для большинства\n * случаев является предпочтительным.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">И дело не в том, что бы как можно больше делегировать работы выводу типов экономя тем самым драгоценное время, а в том, что система типов <em>React</em>, устанавливаемая из репозиториев <code>@types</code>, не имеет достаточно высокого уровня типобезопасности. Поскольку это очень щекотливая тема её освещение стоит начать с самого начала, а именно с перечисления типов к которым может принадлежать возвращаемое значение.</p><p class=\"content__paragraph\">И так, любое допустимое возвращаемое компонентом значение, в системе типов <em>React</em>, может быть представлено типом <code>ReactNode</code> являющимся объединением (<code>Union</code>) определяемого типами <code>ReactChild | ReactFragment | ReactPortal | boolean | null | undefined</code>. Тип <code>ReactChild</code> также представляет собой объединение типов <code>ReactElement&#x3C;Props, Type> | ReactText</code>. Первый, как уже было рассмотрено ранее, представляет экземпляр любого компонента и элемента <em>React</em>, а второй объединение <code>string | number</code>. <code>ReactFragment</code> представляет объединение для <code>{} | ReactNodeArray</code>. Не сложно догадаться, что <code>ReactNodeArray</code>, это абстракция над <code>Array&#x3C;ReactNode></code>. Оставшийся тип <code>ReactPortal</code> является производным от типа <code>ReactElement</code>. Это может казаться очень запутанным и более того разбираться в этом прямо сейчас нет нужды, поскольку совсем скоро станет ясно, в чем кроется подвох, причиной которого являются два из перечисленных типа.</p><p class=\"content__paragraph\">Первый тип, вносящий смуту, это ранее рассмотренный <code>ReactElement&#x3C;P, T></code> и всё неожиданное поведение которое с ним связанно. Вторым типом вносящий неразбериху стал <code>ReactFragment</code>, поскольку определяющий его пустой объектный тип <code>{}</code> совместим с любым экземпляром объектного типа. По факту, при использовании в качестве типа возвращаемого значения <code>ReactFragment</code> или <code>ReactNode</code> ошибки не возникнет даже если оно будет экземпляром <code>Promise</code> или чего-то ещё. И хотя отсутствие ошибки на этапе компиляции не означает, что её получится избежать во время выполнения, сам сценарий с возвратом ошибочного значения может показаться чересчур надуманным. С какой-то долей вероятности можно с этим согласится, но поскольку идеология <em>TypeScript</em> подразумевает выявление проблем в программах до их запуска, об этом стоило хотя бы упомянуть.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> ReactFragment<span class=\"token punctuation\">,</span> ReactNode <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ReactFragment <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">Promise</span><span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[0] */</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token constant\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ReactNode <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token builtin\">Promise</span><span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[0] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] Ok на этапе компиляции и\n * Error во время выполнения.\n */</span>\n\n\n<span class=\"token comment\">/**[1] */</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\"><span class=\"token constant\">T</span></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">readonly</span> p<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ReactFragment <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">T</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[2] */</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token constant\">D</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> ReactNode <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\"><span class=\"token constant\">T</span></span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[2] */</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [1] определение некоторого класса.\n * [2] Ok на этапе компиляции и\n * Error во время выполнения.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Из всего этого следует, что прибегать к аннотации типа возвращаемого значения стоит только в случаях когда оно принадлежит к <code>number</code>, <code>string</code>, <code>boolean</code>, <code>null</code> или массиву элементы которого принадлежат к оному из четырех перечисленных типов. Да и, то при острой необходимости. В остальных случаях целесообразней возложить эту работу на вывод типов, для которого это обычное дело.</p><p class=\"content__paragraph\">Последнее, что осталось без внимания, это событийный механизм или если быть точнее определение слушателей событий. Для этого в системе типов <em>React</em> определен специальный обобщенный тип <code>ReactEventHandler&#x3C;T></code> ожидающий в качестве аргумента типа тип представляющий нативный <em>dom элемент</em>, которому будет установлен текущий слушатель событий.</p><p class=\"content__paragraph\">Представим сценарий в котором по нажатию на кнопку с типом <code>submit</code> необходимо вернуть первоначальные значения элементов формы. Для этого потребуется подписать элемент формы на событие <code>submit</code> и по его возникновению вызвать у нативного элемента формы, ссылка на которую доступна через свойство событийного объекта <code>target</code>, метод <code>reset</code>.</p><p class=\"content__paragraph\">Первым делом реализация подобного сценария потребует импорта обобщенного типа <code>ReactEventHandler&#x3C;T></code>, который в качестве аргумента типа получит тип нативного <em>dom элемента</em> <code>HTMLFormElement</code>, после чего будет указан в аннотации слушателя событий <code>form_submitHandler</code>. Выбор типа нативного <em>dom элемента</em>, в данном случае <code>HTMLFormElement</code>, обуславливается типом элемента, которому устанавливается слушатель событий, в данном случае <code>&#x3C;form></code>. </p><p class=\"content__paragraph\">Стоит также обратить внимание, что единственный параметр слушателя событий в аннотации типа не нуждается, поскольку вывод типов опирается на обобщенный тип <code>ReactEvenHandler&#x3C;T></code>.</p><p class=\"content__paragraph\">По возникновению события, первым делом необходимо предотвратить поведение по умолчанию, что бы избежать перезагрузки вкладки браузера. Поскольку ссылка на нативную форму доступна через определенное в объекте события свойство <code>target</code>, которое принадлежит к типу <code>EventTarget</code>, то перед присвоением её переменной <code>form</code> появляется необходимость в приведении к типу <code>HTMLFormElement</code> с помощью оператора <code>as</code>. После это можно вызывать нативный метод <code>reset</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                    <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>ReactEventHandler<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token comment\">/**[1]                 [2]              [3]           [4] */</span>\n    <span class=\"token keyword\">const</span> form_submitHandler<span class=\"token operator\">:</span> ReactEventHandler<span class=\"token operator\">&lt;</span>HTMLFormElement<span class=\"token operator\">></span> <span class=\"token operator\">=</span> event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n        event<span class=\"token punctuation\">.</span><span class=\"token function\">preventDefault</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[5] */</span>\n\n        <span class=\"token comment\">/**  [6]        [7]              [8] */</span>\n        <span class=\"token keyword\">let</span> form <span class=\"token operator\">=</span> event<span class=\"token punctuation\">.</span>target <span class=\"token keyword\">as</span> HTMLFormElement<span class=\"token punctuation\">;</span>\n        form<span class=\"token punctuation\">.</span><span class=\"token function\">reset</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[9] */</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n                            <span class=\"token comment\">/**[10] */</span>\n        <span class=\"token operator\">&lt;</span>form onSubmit<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>form_submitHandler<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span>button <span class=\"token keyword\">type</span><span class=\"token operator\">=</span><span class=\"token string\">\"submit\"</span><span class=\"token operator\">></span>submit<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>form<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] импорт обобщенного функционального типа\n * которому установив в качестве аргумента типа\n * тип нативного элемента HTMLFormElement [3]\n * использовали в аннотации типа [2] переменной\n * form_submitHandler [1], которой в качестве\n * значения присвоили функцию слушатель события\n * единственный параметр которой не нуждается в\n * явной аннотации типа [4], поскольку вывод типов\n * опирается на тип ReactEventHandler&lt;T>.\n * \n * При возникновении события первым делом происходит\n * предотвращение поведения по умолчанию, что бы избежать\n * перезагрузки вкладки браузера [5]. Затем создается\n * переменная form [6] которой присваивается ссылка на\n * нативный dom элемент доступный через свойство определенное\n * в объекте события target [7] которое при помощи оператора \n * as приведено к нужному типу нативного dom элемента HTMLFormElement [8].\n * \n * На следующем шаге вызывается нативный метод сброса значений формы reset [9]\n * \n * [10] установка слушателя событий React элементу form.\n * \n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Несмотря на то, что такой способ типизирования слушателей событий является предпочтительным, также не будет лишним рассмотреть и другой имеющийся вариант состоящий в описании непосредственно сигнатуры функции.</p><p class=\"content__paragraph\">Для этого, в нашем конкретном случае, необходимо импортировать обобщенный тип <code>FormEvent&#x3C;T></code>, которому перед размещением в аннотации единственного параметра слушателя события необходимо в качестве аргумента события указать тип нативного <em>dom элемента</em> <code>HTMLFormElement</code>. Также стоит напомнить, что в аннотации возвращаемого из слушателя события значения нет необходимости. Подобную рутинную работу необходимо делегировать выводу типов.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>FormEvent<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                              <span class=\"token comment\">/**[1]      [2]           [3]          [4] */</span>\n    <span class=\"token keyword\">const</span> form_submitHandler <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>event<span class=\"token operator\">:</span> FormEvent<span class=\"token operator\">&lt;</span>HTMLFormElement<span class=\"token operator\">></span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span>\n\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>form onSubmit<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>form_submitHandler<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span>button <span class=\"token keyword\">type</span><span class=\"token operator\">=</span><span class=\"token string\">\"submit\"</span><span class=\"token operator\">></span>submit<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>form<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] импорт обобщенного типа FormEvent&lt;T>\n * которому перед добавлением в аннотацию типа [2]\n * единственного параметра слушателя события [1] \n * необходимо установить в качестве аргумента типа\n * тип нативного dom элемента HTMLFormElement [3].\n * Указании типа к которому принадлежит возвращаемое\n * из слушателя события значения было указанно лишь\n * для того, что бы напомнить об отсутствии в этом необходимости.\n * Подобную работу нужно делегировать выводу типов.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Работа непосредственно с формой обусловила выбор более конкретного типа события, каковым в данном примере стал обобщенный тип <code>FormEvent&#x3C;T></code>. При других условиях потребуются другие событийные типы. Кроме того, всегда можно сделать выбор в пользу базового для всех событийных типов <code>SyntheticEvent&#x3C;T></code> ожидающего в качестве аргумента типа тип нативного <em>dom элемента</em>.</p><p class=\"content__paragraph\">Кроме этого, функциональным компонентам доступна мемоизация слушателей событий при помощи универсального хука <code>useCallback&#x3C;T>()</code>. Для этого понадобится импортировать универсальную функцию определяющую два обязательных параметра. В качестве первого параметра ожидается функция чье описание устанавливается в качестве аргумента функционального типа. Второй параметр принадлежит к типу массива, изменение элементов которого приводит к переинициализации функции переданной в качестве первого параметра. Поскольку в качестве аргумента функционального тпа ожидается тип описывающий первый параметр хука, то нет необходимости в аннотациях типа её параметров. Или в данном случае её единственного параметра представляющего объект события. В остальном же реализация ничем не отличается от предыдущего примера, поэтому повторяющийся код будет исключён.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">                <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>useCallback<span class=\"token punctuation\">,</span> ReactEventHandler<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Form</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n                                 <span class=\"token comment\">/**[1]                    [2]                       [3]*/</span>\n    <span class=\"token keyword\">const</span> form_submitHandler <span class=\"token operator\">=</span> <span class=\"token generic-function\"><span class=\"token function\">useCallback</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>ReactEventHandler<span class=\"token operator\">&lt;</span>HTMLFormElement<span class=\"token operator\">>></span></span></span><span class=\"token punctuation\">(</span>event <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\">/**[4] */</span> <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n        <span class=\"token operator\">&lt;</span>form onSubmit<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>form_submitHandler<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>\n            <span class=\"token operator\">&lt;</span>button <span class=\"token keyword\">type</span><span class=\"token operator\">=</span><span class=\"token string\">\"submit\"</span><span class=\"token operator\">></span>submit<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n        <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>form<span class=\"token operator\">></span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">/**\n * [0] импорт универсальной функции useCallback&lt;T>()\n * принимающей в качестве первого обязательного параметра\n * функцию [3], описание которой устанавливается в качестве\n * аргумента функционального типа [1]. D качестве второго\n * обязательного параметра ожидается массив [4] со значениями\n * изменение которых приводит переинициализации функции переданной\n * в качестве первого аргумента.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">На этом рассмотрение типизирования функционального компонента определенного как <em>Function Declaration</em>, завершено. И поскольку тема получилась довольно не маленькая исключим затягивание и перейдем к рассмотрению следующего вида функциональных компонентов.</p></section>\n<section class=\"content__section\" id=\"Opredelenie_komponenta_kak_Function_Expression\"><h2 class=\"content__heading_2\">\n    <button class=\"content__button_copy-to-buffer\" path=\"Opredelenie_komponenta_kak_Function_Expression\">\n      <svg class=\"svg-icon copy-to-buffer-button__svg-icon\" width=\"24\" height=\"24\" viewBox=\"0 0 24 24\">\n        <use xlink:href=\"#iconmonstr-link\"></use>\n      </svg>\n      <div class=\"content__tooltip_copy-to-buffer tooltip\">\n        Скопировать ссылку в буффер обмена\n      </div>\n    </button>\n  <span>Определение компонента как Function Expression</span></h2><p class=\"content__paragraph\">Поскольку самое необходимое относящиеся ко всем видам <em>React</em> компонентов было рассмотрено в предыдущей теме, в этой и последующих, повествование будет сосредоточено исключительно на различиях.</p><p class=\"content__paragraph\">Для определения функционального компонента как <em>Function Expression</em> декларация типов <em>React</em> предусматривает вспомогательный обобщенный тип <code>FC&#x3C;Props></code>, чей идентификатор (имя) является сокращением от <em>Function Component</em>, а аргумент типа представляет пропсы и является необязательным. Поскольку вывод типов ориентируется на тип пропсов указанный или присущий по умолчанию в качестве аргумента типа, то в аннотировании первого параметра функционального компонента нет надобности. Помимо этого, тип пропсов, по умолчанию описывает необязательное поле <code>children</code> принадлежащего к типу <code>ReactNode</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">             <span class=\"token comment\">/**[0] */</span>\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token constant\">FC</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n          <span class=\"token comment\">/**[1]       [2] */</span>\n<span class=\"token keyword\">const</span> Timer<span class=\"token operator\">:</span> <span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>children<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Is Timer<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] импорт обобщенного типа FC&lt;P>\n * который указан в аннотации без\n * установки аргумента типа [1] и\n * несмотря на это ошибки при деструктуризации\n * поля children не возникает даже без аннотации\n * типа первого параметра [2]\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если тип пропсов указан в качестве аргумента типа <code>FC&#x3C;P></code> и при этом не описывает поле <code>children</code>, то оно всё равно будет определенно в объекте пропсов доступного в качестве первого параметра функционального компонента.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token constant\">FC</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TimerProps</span> <span class=\"token punctuation\">{</span>\n    duration<span class=\"token operator\">:</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">/**[0] */</span>\n<span class=\"token punctuation\">}</span>\n                 <span class=\"token comment\">/**[1]                     [3]*/</span>\n<span class=\"token keyword\">const</span> Timer<span class=\"token operator\">:</span> <span class=\"token constant\">FC</span><span class=\"token operator\">&lt;</span>TimerProps<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>duration<span class=\"token punctuation\">,</span> children<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Is Timer<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> Timer<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] несмотря на то, что тип представляющий\n * пропсы и указанный в качестве аргумента\n * типа FC&lt;P> [1] не описывает поле children\n * при их деструктуризации ошибки не возникает [3]\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В остальном все, что было рассмотрено в предыдущей теме относительно пропсов и <code>children</code> идентично и для данного способа типизирования функциональных компонентов.</p><p class=\"content__paragraph\">При возникновении необходимости в определении второго параметра функционального компонента придется самостоятельно указывать аннотацию типа, поскольку по каким-то причинам обобщенный тип <code>FC&#x3C;P></code> этого не предусматривает.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token constant\">FC</span> <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TimerProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n\n                             <span class=\"token comment\">/**[1]   [2] */</span>\n<span class=\"token keyword\">const</span> Timer<span class=\"token operator\">:</span> <span class=\"token constant\">FC</span><span class=\"token operator\">&lt;</span>TimerProps<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Is Timer<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * Первый параметр [0] выводится как\n * PropsWithChildren&lt;TimerProps>, а\n * второй [2] как any, поскольку обобщенный\n * тип FC&lt;P> не предусматривает его наличие.\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">В остальном все рассмотренное относительно рефов в теме посвященной функциональным компонентам определенным как <em>Function Declaration</em>, верно и для текущего вида определения.</p><p class=\"content__paragraph\">При необходимости во втором параметре можно отказаться от типа <code>FC&#x3C;P></code> в пользу ранее рассмотренного типа <code>ForwardRefRenderFunction&#x3C;T, P></code>. При указании данного типа в аннотации функционального компонента, пропадает необходимость, как в явном аннотировании типов его параметров, так и в указании аргументов типа универсальной функции <code>forwardRef&#x3C;T, P>()</code>.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span> <span class=\"token constant\">FC</span><span class=\"token punctuation\">,</span> forwardRef<span class=\"token punctuation\">,</span> ForwardRefRenderFunction <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TimerProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n\n                    <span class=\"token comment\">/**[1] */</span>\n<span class=\"token keyword\">const</span> Timer<span class=\"token operator\">:</span> ForwardRefRenderFunction<span class=\"token operator\">&lt;</span>HTMLDivElement<span class=\"token punctuation\">,</span> TimerProps<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Is Timer<span class=\"token operator\">!</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span>\n\n\n                        <span class=\"token comment\">/**[2] */</span>\n<span class=\"token keyword\">const</span> TimerWithRef <span class=\"token operator\">=</span> <span class=\"token function\">forwardRef</span><span class=\"token punctuation\">(</span>Timer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> TimerWithRef<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] импорт типа для указания его в аннотации\n * функционального компонента [1] определяющего второй\n * параметр ref. После этого нет необходимости в явной\n * аннотации типов как обоих параметров функционального\n * компонента, так и универсальной функции forwardRef&lt;T, P>().\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Важной особенностью использования обобщенного типа <code>FC&#x3C;P></code> заключается в том, что он, помимо типа представляющего пропсы, также содержит описание типа возвращаемого функцией значения. Вроде бы так и должно быть, но нюанс заключается в том, что возвращаемое значение обязательно должно принадлежать к типу совместимому с <code>ReactElement&#x3C;P, T></code>. Простыми словами на этапе компиляции возникнет ошибка если функциональный компонент, определенный как <em>Function Expression</em>, будет возвращать значение принадлежащие к типам <code>number</code>, <code>string</code>, <code>boolean</code> или абсолютно любому массиву.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span><span class=\"token constant\">FC</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">A</span><span class=\"token operator\">:</span> <span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">0123</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">B</span><span class=\"token operator\">:</span> <span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token string\">\"0123\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">C</span><span class=\"token operator\">:</span> <span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">D</span><span class=\"token operator\">:</span> <span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Error</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">E</span><span class=\"token operator\">:</span> <span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">F</span><span class=\"token operator\">:</span> <span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span><span class=\"token constant\">E</span><span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span>\n<span class=\"token keyword\">const</span> <span class=\"token constant\">G</span><span class=\"token operator\">:</span> <span class=\"token function-variable function\">FC</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">></span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Ok</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Поэтому в случае, предполагающем, что функциональный компонент, определенный как <em>Function Expression</em>, будет возвращать значение отличное от <code>ReactElement&#x3C;P, T></code>, потребуется самостоятельно описать его сигнатуру. Что не представляет никакого труда.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>MutableRefObject<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TimerProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">Timer</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> TimerProps<span class=\"token punctuation\">,</span> ref<span class=\"token operator\">:</span> MutableRefObject<span class=\"token operator\">&lt;</span>HTMLDivElement<span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">Если в подобном определении функциональных компонентов существует частая потребность, будет целесообразней определить собственный тип подробно описывающий сигнатуру функции.</p><p class=\"content__paragraph\">Для этого потребуется определить обобщенный тип с двумя необязательными параметрами. Первый необязательный параметр представляющий тип пропсов должен расширять и к тому же указывать в качестве типа по умолчанию тип <code>object</code>. Второй необязательный параметр типа должен проделать тот же процесс только для нативного типа <code>HTMLElement</code>.</p><p class=\"content__paragraph\">Чтобы не заморачиваться в определении <code>children</code>, указываем принадлежность первого параметра функции к уже знакомому обобщенному типу <code>PropsWithChildren&#x3C;P></code>, которому в качестве аргумента типа устанавливаем первый параметр типа <code>P</code>. Второму необязательному параметру функции указываем принадлежность к обобщенному типу <code>MutableRefObject&#x3C;E></code> в качестве аргумента типа которому устанавливаем второй параметр типа <code>E</code>. Осталось лишь указать принадлежность возвращаемого функцией значения к типу <code>ReactNode</code> и тип <code>CFC&#x3C;P, E></code>, что является сокращением от <em>Custom Functional Component</em>, готов сэкономить время и нервы разработчика.</p><div class=\"content__code\">\n    <div class=\"content__code-panel_top content__code-panel_lang_ts\">\n        <span class=\"content_code-label_filepath\"></span>\n        <span class=\"content_code-label_lang\">ts</span>\n    </div>\n    <div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// file CFC.ts</span>\n\n<span class=\"token keyword\">import</span> React<span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span>MutableRefObject<span class=\"token punctuation\">,</span> ReactNode<span class=\"token punctuation\">,</span> PropsWithChildren<span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n\n         <span class=\"token comment\">/**[0][1]         [2]     [3][4]           [5]            [6]                       [7]                      [8]             [9]*/</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\"><span class=\"token constant\">CFC</span><span class=\"token operator\">&lt;</span><span class=\"token constant\">P</span> <span class=\"token keyword\">extends</span> object <span class=\"token operator\">=</span> object<span class=\"token punctuation\">,</span> <span class=\"token constant\">E</span> <span class=\"token keyword\">extends</span> HTMLElement <span class=\"token operator\">=</span> HTMLElement<span class=\"token operator\">></span></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token operator\">:</span> PropsWithChildren<span class=\"token operator\">&lt;</span><span class=\"token constant\">P</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> ref<span class=\"token operator\">?</span><span class=\"token operator\">:</span> MutableRefObject<span class=\"token operator\">&lt;</span><span class=\"token constant\">E</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> ReactNode<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] определяем обобщенный тип CustomFunctionComponent\n * или сокращенно CFC первый необязательный параметр представляющего\n * пропсы которого [1] расширяет [2] и устанавливает по умолчанию [3]\n * тип object. Второй необязательный параметр представляющий тип нативного\n * dom элемента [4] расширяет [5] и устанавливает по умолчанию [6] тип HTMLElement.\n * \n * [7] устанавливаем принадлежность первого параметра функционального типа к\n * обобщенному типу PropsWithChildren&lt;P> которому в качестве аргумента типа передаем первый\n * параметр типа. \n * \n * [8] определяем принадлежность второго необязательного параметра к обобщенному типу\n * MutableRefObject&lt;E> которому в качестве аргумента типа устанавливаем второй параметр типа.\n * \n * [9] тип возвращаемого значения определяем как ReactNode.\n *  \n */</span>\n\n\n<span class=\"token comment\">// file Timer.tsx</span>\n<span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">\"react\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span><span class=\"token constant\">CFC</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">\"./CFC\"</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">/**[0] */</span>\n\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">interface</span> <span class=\"token class-name\">TimerProps</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n          <span class=\"token comment\">/**[1]    [2]           [3]            [4]   [5]     [6]*/</span>\n<span class=\"token keyword\">const</span> Timer<span class=\"token operator\">:</span> <span class=\"token constant\">CFC</span><span class=\"token operator\">&lt;</span>TimerProps<span class=\"token punctuation\">,</span> HTMLDivElement<span class=\"token operator\">></span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span>props<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token number\">123</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/**\n * [0] импорт CustomFunctionComponent для\n * указания его в качестве типа функционального\n * компонента определенного как Function Expression [1].\n * В качестве первого параметра типа устанавливается тип\n * представляющий пропсы [2], а в качестве второго тип нативного\n * dom элемента с которым будет ассоциирован объект реф [3].\n * При таком подходе отпадает необходимость в явном указании аннотации\n * типов как пропсов [4], так и рефы [5]. Кроме того, возвращаемое значение\n * может принадлежать к любому типу совместимому с типом ReactNode [6]\n */</span></code></pre></div>\n    <div class=\"content__code-panel_bottom content__code-panel_lang_ts\"></div>\n</div><p class=\"content__paragraph\">На этом тема относящаяся функциональных компонентов себя полностью исчерпала, поэтому без лишних слов двигаемся к следующей теме посвященной классовым компонентам.</p></section>","commitInfoAll":[{"committedDate":"2020-10-19T05:58:44Z","message":"book(добавление): add content in chapter 049\n\nadd content in chapter 049","messageHeadline":"book(добавление): add content in chapter 049","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"nauchikus","bio":"@TechnoFanatic(\"🍬\")\r\n","location":null,"avatarUrl":"https://avatars.githubusercontent.com/u/31518738?v=4"}},{"committedDate":"2021-03-22T08:08:33Z","message":"fixed grammar and syntax errors in the text","messageHeadline":"fixed grammar and syntax errors in the text","pushedDate":null,"authoredByCommitter":true,"committer":{"name":"mindyourlifeguide","bio":"Front-end developer","location":"Kyiv, Ukraine","avatarUrl":"https://avatars.githubusercontent.com/u/35348648?u=d52456eed154db660092623fe6e0ebb516677a95&v=4"}}],"fileOnGithubLink":"https://github.com/nauchikus/typescript-definitive-guide/blob/book/undefined/049\\.\\(React\\) Функциональные компоненты/content.md"},"pageNavDataAll":[{"name":"Что такое и для чего нужен TypeScript","path":"Chto_takoe_i_dlya_chego_nujen_TypeScript","sections":[{"name":"Что такое TypeScript","path":"Chto_takoe_TypeScript"},{"name":"История TypeScript","path":"Istoriya_TypeScript"},{"name":"Для чего нужен TypeScript","path":"Dlya_chego_nujen_TypeScript"},{"name":"Зачем разработчику TypeScript","path":"Zachem_razrabotchiku_TypeScript"}]},{"name":"Вступление","path":"Vstuplenie","sections":[]},{"name":"Система типов, тип данных, значимые и ссылочные типы","path":"Sistema_tipov,tip_dannyh,znachimye_i_ssylochnye_tipy","sections":[{"name":"Система Типов","path":"Sistema_Tipov"},{"name":"Тип данных (тип)","path":"Tip_dannyh_(tip)"},{"name":"Тип данных, передающийся по значению (примитивный тип)","path":"Tip_dannyh,peredaushchiisya_po_znacheniu_(primitivnyi_tip)"},{"name":"Тип данных, передающийся по ссылке","path":"Tip_dannyh,peredaushchiisya_po_ssylke"}]},{"name":"Связывание, типизация, вывод типов","path":"Svyazyvanie,tipizaciya,vyvod_tipov","sections":[{"name":"Обработка кода компилятором","path":"Obrabotka_koda_kompilyatorom"},{"name":"Лексический анализ (токенизация - tokenizing)","path":"Leksicheskii_analiz_(tokenizaciya_-_tokenizing)"},{"name":"Синтаксический анализ (разбор - parsing)","path":"Sintaksicheskii_analiz_(razbor_-_parsing)"},{"name":"Семантический анализ","path":"Semanticheskii_analiz"},{"name":"Связывание (Binding)","path":"Svyazyvanie_(Binding)"},{"name":"Типизация","path":"Tipizaciya"},{"name":"Вывод Типов (type inference)","path":"Vyvod_Tipov_(type_inference)"}]},{"name":"Преобразование типов","path":"Preobrazovanie_tipov","sections":[{"name":"Неявные Преобразования","path":"Neyavnye_Preobrazovaniya"},{"name":"Явные Преобразования","path":"Yavnye_Preobrazovaniya"}]},{"name":"Типизированные и нетипизированные языки программирования","path":"Tipizirovannye_i_netipizirovannye_yazyki_programmirovaniya","sections":[{"name":"Нетипизированные языки","path":"Netipizirovannye_yazyki"},{"name":"Типизированные языки","path":"Tipizirovannye_yazyki"}]},{"name":"Статическая и динамическая типизация","path":"Staticheskaya_i_dinamicheskaya_tipizaciya","sections":[{"name":"Статическая типизация (Static Typing)","path":"Staticheskaya_tipizaciya_(Static_Typing)"},{"name":"Динамическая Типизация (Dynamic Typing)","path":"Dinamicheskaya_Tipizaciya_(Dynamic_Typing)"}]},{"name":"Сильная и слабая типизация","path":"Silnaya_i_slabaya_tipizaciya","sections":[{"name":"Сильная типизация (strongly typed)","path":"Silnaya_tipizaciya_(strongly_typed)"},{"name":"Слабая типизация (weakly typed)","path":"Slabaya_tipizaciya_(weakly_typed)"}]},{"name":"Явная и неявная типизация","path":"Yavnaya_i_neyavnaya_tipizaciya","sections":[{"name":"Явная типизация (explicit typing)","path":"Yavnaya_tipizaciya_(explicit_typing)"},{"name":"Неявная типизация (implicit typing)","path":"Neyavnaya_tipizaciya_(implicit_typing)"}]},{"name":"Совместимость типов на основе вида типизации","path":"Sovmestimost_tipov_na_osnove_vida_tipizacii","sections":[{"name":"Совместимость типов (Types Compatibility)","path":"Sovmestimost_tipov_(Types_Compatibility)"},{"name":"Номинативная Типизация (nominative typing)","path":"Nominativnaya_Tipizaciya_(nominative_typing)"},{"name":"Структурная Типизация (structural typing)","path":"Strukturnaya_Tipizaciya_(structural_typing)"},{"name":"Утиная Типизация (Duck typing)","path":"Utinaya_Tipizaciya_(Duck_typing)"}]},{"name":"Совместимость типов на основе вариантности","path":"Sovmestimost_tipov_na_osnove_variantnosti","sections":[{"name":"Вариантность","path":"Variantnost"},{"name":"Иерархия наследования","path":"Ierarhiya_nasledovaniya"},{"name":"Ковариантность","path":"Kovariantnost"},{"name":"Контравариантность","path":"Kontravariantnost"},{"name":"Инвариантность","path":"Invariantnost"},{"name":"Бивариантность","path":"Bivariantnost"}]},{"name":"Аннотация Типов","path":"Annotaciya_Tipov","sections":[{"name":"Аннотация Типов - общее","path":"Annotaciya_Tipov_-_obshchee"},{"name":"Аннотация типа","path":"Annotaciya_tipa"},{"name":"Синтаксические конструкции var, let, const","path":"Sintaksicheskie_konstrukcii_var,let,const"},{"name":"Функции (function)","path":"Funkcii_(function)"},{"name":"Стрелочные Функции (arrow function)","path":"Strelochnye_Funkcii_(arrow_function)"},{"name":"Классы (class)","path":"Klassy_(class)"},{"name":"Сравнение Синтаксиса TypeScript и JavaScript","path":"Sravnenie_Sintaksisa_TypeScript_i_JavaScript"},{"name":"Итог","path":"Itog"}]},{"name":"Базовый Тип Any","path":"Bazovyi_Tip_Any","sections":[{"name":"Any (any) произвольный тип","path":"Any_(any)_proizvolnyi_tip"}]},{"name":"Примитивные типы Number, String, Boolean, Symbol, BigInt","path":"Primitivnye_tipy_Number,String,Boolean,Symbol,BigInt","sections":[{"name":"Важно","path":"Vajno"},{"name":"Number (number) примитивный числовой тип","path":"Number_(number)_primitivnyi_chislovoi_tip"},{"name":"String (string) примитивный строковый тип","path":"String_(string)_primitivnyi_strokovyi_tip"},{"name":"Boolean (boolean) примитивный логический тип","path":"Boolean_(boolean)_primitivnyi_logicheskii_tip"},{"name":"Symbol (symbol) примитивный символьный тип","path":"Symbol_(symbol)_primitivnyi_simvolnyi_tip"},{"name":"BigInt (bigint) примитивный числовой тип","path":"BigInt_(bigint)_primitivnyi_chislovoi_tip"}]},{"name":"Примитивные типы Null, Undefined, Void, Never, Unknown","path":"Primitivnye_tipy_Null,Undefined,Void,Never,Unknown","sections":[{"name":"Важно","path":"Vajno"},{"name":"Null (null) примитивный null тип","path":"Null_(null)_primitivnyi_null_tip"},{"name":"Undefined (undefined) примитивный неопределенный тип","path":"Undefined_(undefined)_primitivnyi_neopredelennyi_tip"},{"name":"Void (void) отсутствие конкретного типа","path":"Void_(void)_otsutstvie_konkretnogo_tipa"},{"name":"Never (never) примитивный тип","path":"Never_(never)_primitivnyi_tip"},{"name":"Unknown (unknown)","path":"Unknown_(unknown)"}]},{"name":"Примитивный Тип Enum","path":"Primitivnyi_Tip_Enum","sections":[{"name":"Enum (enum) примитивный перечисляемый тип","path":"Enum_(enum)_primitivnyi_perechislyaemyi_tip"},{"name":"Перечисления с числовым значением","path":"Perechisleniya_s_chislovym_znacheniem"},{"name":"Перечисления со строковым значением","path":"Perechisleniya_so_strokovym_znacheniem"},{"name":"Смешанное перечисление (mixed enum)","path":"Smeshannoe_perechislenie_(mixed_enum)"},{"name":"Перечисление в качестве типа данных","path":"Perechislenie_v_kachestve_tipa_dannyh"},{"name":"Перечисление const с числовым и строковым значением","path":"Perechislenie_const_s_chislovym_i_strokovym_znacheniem"},{"name":"Когда стоит применять enum?","path":"Kogda_stoit_primenyat_enum?"}]},{"name":"Типы - Union, Intersection","path":"Tipy_-_Union,Intersection","sections":[{"name":"Тип Объединение (Union Types)","path":"Tip_Obedinenie_(Union_Types)"},{"name":"Тип Пересечение (Intersection Type)","path":"Tip_Peresechenie_(Intersection_Type)"}]},{"name":"Type Queries (запросы типа), Alias (псевдонимы типа)","path":"Type_Queries_(zaprosy_tipa),Alias_(psevdonimy_tipa)","sections":[{"name":"Запросы Типа (Type Queries)","path":"Zaprosy_Tipa_(Type_Queries)"},{"name":"Псевдонимы Типов (Type Aliases)","path":"Psevdonimy_Tipov_(Type_Aliases)"}]},{"name":"Примитивные литеральные типы Number, String, Template String, Boolean, Unique Symbol, Enum","path":"Primitivnye_literalnye_tipy_Number,String,Template_String,Boolean,Unique_Symbol,Enum","sections":[{"name":"Литеральный тип Number (Numeric Literal Types)","path":"Literalnyi_tip_Number_(Numeric_Literal_Types)"},{"name":"Литеральный тип String (String Literal Types)","path":"Literalnyi_tip_String_(String_Literal_Types)"},{"name":"Шаблонный литеральный тип String (Template String Literal Types)","path":"Shablonnyi_literalnyi_tip_String_(Template_String_Literal_Types)"},{"name":"Литеральный Тип Boolean (Boolean Literal Types)","path":"Literalnyi_Tip_Boolean_(Boolean_Literal_Types)"},{"name":"Литеральный Тип Unique Symbol (unique symbol) уникальный символьный тип","path":"Literalnyi_Tip_Unique_Symbol_(unique_symbol)_unikalnyi_simvolnyi_tip"},{"name":"Литеральный тип Enum (Enum Literal Types)","path":"Literalnyi_tip_Enum_(Enum_Literal_Types)"}]},{"name":"Object, Array, Tuple","path":"Object,Array,Tuple","sections":[{"name":"Object (object) — ссылочный объектный тип","path":"Object_(object)_—_ssylochnyi_obektnyi_tip"},{"name":"Array (type[]) ссылочный массивоподобный тип","path":"Array_(type[])_ssylochnyi_massivopodobnyi_tip"},{"name":"Tuple ([T0, T1, …, Tn]) тип кортеж","path":"Tuple_([T0,T1,…,Tn])_tip_kortej"}]},{"name":"Function, Functional Types","path":"Function,Functional_Types","sections":[{"name":"Function Types - тип функция","path":"Function_Types_-_tip_funkciya"},{"name":"Functional Types - функциональный тип","path":"Functional_Types_-_funkcionalnyi_tip"},{"name":"this в сигнатуре функции","path":"this_v_signature_funkcii"}]},{"name":"Interfaces","path":"Interfaces","sections":[{"name":"Общая теория","path":"Obshchaya_teoriya"},{"name":"Интерфейс в TypeScript","path":"Interfeis_v_TypeScript"},{"name":"Объявление (declaration)","path":"Obyavlenie_(declaration)"},{"name":"Конвенции именования интерфейсов","path":"Konvencii_imenovaniya_interfeisov"},{"name":"Реализация интерфейса (implements)","path":"Realizaciya_interfeisa_(implements)"},{"name":"Декларация свойств get и set (accessors)","path":"Deklaraciya_svoistv_get_i_set_(accessors)"},{"name":"Указание интерфейса в качестве типа (interface types)","path":"Ukazanie_interfeisa_v_kachestve_tipa_(interface_types)"},{"name":"Расширение интерфейсов (extends interface)","path":"Rasshirenie_interfeisov_(extends_interface)"},{"name":"Расширение интерфейсом класса (extends class)","path":"Rasshirenie_interfeisom_klassa_(extends_class)"},{"name":"Описание класса (функции-конструктора)","path":"Opisanie_klassa_(funkcii-konstruktora)"},{"name":"Описание функционального выражения","path":"Opisanie_funkcionalnogo_vyrajeniya"},{"name":"Описание индексных членов в объектных типов","path":"Opisanie_indeksnyh_chlenov_v_obektnyh_tipov"},{"name":"Инлайн интерфейсы (Inline Interface)","path":"Inlain_interfeisy_(Inline_Interface)"},{"name":"Слияние интерфейсов","path":"Sliyanie_interfeisov"}]},{"name":"Объектные типы с индексными членами (объектный тип с динамическими ключами)","path":"Obektnye_tipy_s_indeksnymi_chlenami_(obektnyi_tip_s_dinamicheskimi_kluchami)","sections":[{"name":"Индексные члены (определение динамических ключей)","path":"Indeksnye_chleny_(opredelenie_dinamicheskih_kluchei)"},{"name":"Строгая проверка при обращении к динамическим ключам","path":"Strogaya_proverka_pri_obrashchenii_k_dinamicheskim_klucham"},{"name":"Запрет обращения к динамическим ключам через точечную нотацию","path":"Zapret_obrashcheniya_k_dinamicheskim_klucham_cherez_tochechnuu_notaciu"},{"name":"Тонкости совместимости индексной сигнатурой с необязательными полями","path":"Tonkosti_sovmestimosti_indeksnoi_signaturoi_s_neobyazatelnymi_polyami"}]},{"name":"Модификаторы доступа (Access Modifiers)","path":"Modifikatory_dostupa_(Access_Modifiers)","sections":[{"name":"Модификатор доступа public (публичный)","path":"Modifikator_dostupa_public_(publichnyi)"},{"name":"Модификатор доступа private (закрытый или скрытый)","path":"Modifikator_dostupa_private_(zakrytyi_ili_skrytyi)"},{"name":"Модификатор доступа protected (защищенный)","path":"Modifikator_dostupa_protected_(zashchishchennyi)"},{"name":"Модификаторы доступа и конструкторы класса","path":"Modifikatory_dostupa_i_konstruktory_klassa"},{"name":"Быстрое объявление полей","path":"Bystroe_obyavlenie_polei"}]},{"name":"Закрытые поля определенные спецификацией ECMAScript","path":"Zakrytye_polya_opredelennye_specifikaciei_ECMAScript","sections":[{"name":"Нативный закрытый (private) модификатор доступа","path":"Nativnyi_zakrytyi_(private)_modifikator_dostupa"}]},{"name":"Абстрактные классы (abstract classes)","path":"Abstraktnye_klassy_(abstract_classes)","sections":[{"name":"Общие характеристики","path":"Obshchie_harakteristiki"},{"name":"Теория","path":"Teoriya"}]},{"name":"Полиморфный тип this","path":"Polimorfnyi_tip_this","sections":[{"name":"this - как тип","path":"this_-_kak_tip"}]},{"name":"Модификатор readonly (только для чтения)","path":"Modifikator_readonly_(tolko_dlya_chteniya)","sections":[{"name":"Модификатор readonly","path":"Modifikator_readonly"}]},{"name":"Definite Assignment Assertion Modifier","path":"Definite_Assignment_Assertion_Modifier","sections":[{"name":"Модификатор утверждения не принадлежности значения к типу undefined","path":"Modifikator_utverjdeniya_ne_prinadlejnosti_znacheniya_k_tipu_undefined"}]},{"name":"Классы — Тонкости","path":"Klassy_—_Tonkosti","sections":[{"name":"Классы - Тонкости implements","path":"Klassy_-_Tonkosti_implements"},{"name":"Частичное слияние интерфейса с классом","path":"Chastichnoe_sliyanie_interfeisa_s_klassom"},{"name":"Переопределение свойств полями и наоборот при наследовании","path":"Pereopredelenie_svoistv_polyami_i_naoborot_pri_nasledovanii"}]},{"name":"Различия var, let, const и модификатора readonly при неявном указании примитивных типов","path":"Razlichiya_var,let,const_i_modifikatora_readonly_pri_neyavnom_ukazanii_primitivnyh_tipov","sections":[{"name":"Нюансы на практике","path":"Nuansy_na_praktike"}]},{"name":"Операторы - Optional, Not-Null Not-Undefined, Definite Assignment Assertion","path":"Operatory_-_Optional,Not-Null_Not-Undefined,Definite_Assignment_Assertion","sections":[{"name":"Необязательные поля, параметры и методы (Optional Fields, Parameters and Methods)","path":"Neobyazatelnye_polya,parametry_i_metody_(Optional_Fields,Parameters_and_Methods)"},{"name":"Оператор ! (Non-Null and Non-Undefined Operator)","path":"Operator_!_(Non-Null_and_Non-Undefined_Operator)"},{"name":"Оператор ! (Definite Assignment Assertion)","path":"Operator_!_(Definite_Assignment_Assertion)"}]},{"name":"Обобщения (Generics)","path":"Obobshcheniya_(Generics)","sections":[{"name":"Обобщения - общие понятия","path":"Obobshcheniya_-_obshchie_ponyatiya"},{"name":"Обобщения в TypeScript","path":"Obobshcheniya_v_TypeScript"},{"name":"Параметры типа - extends (generic constraints)","path":"Parametry_tipa_-_extends_(generic_constraints)"},{"name":"Параметра типа - значение по умолчанию = (generic parameter defaults)","path":"Parametra_tipa_-_znachenie_po_umolchaniu_=_(generic_parameter_defaults)"},{"name":"Параметры типа - как тип данных","path":"Parametry_tipa_-_kak_tip_dannyh"}]},{"name":"Дискриминантное объединение (Discriminated Union)","path":"Diskriminantnoe_obedinenie_(Discriminated_Union)","sections":[{"name":"Дискриминантное объединение","path":"Diskriminantnoe_obedinenie"}]},{"name":"Импорт и экспорт только типа","path":"Import_i_eksport_tolko_tipa","sections":[{"name":"Предыстория возникновения import type и export type","path":"Predystoriya_vozniknoveniya_import_type_i_export_type"},{"name":"import type и export type - форма объявления","path":"import_type_i_export_type_-_forma_obyavleniya"},{"name":"Импорт и экспорт только типа на практике","path":"Import_i_eksport_tolko_tipa_na_praktike"},{"name":"Вспомогательный флаг --importsNotUsedAsValues","path":"Vspomogatelnyi_flag_--importsNotUsedAsValues"}]},{"name":"Утверждение типов (Type Assertion)","path":"Utverjdenie_tipov_(Type_Assertion)","sections":[{"name":"Утверждение типов - общее","path":"Utverjdenie_tipov_-_obshchee"},{"name":"Утверждение типа с помощью <Type> синтаксиса","path":"Utverjdenie_tipa_s_pomoshchu_<Type>_sintaksisa"},{"name":"Утверждение типа с помощью оператора as","path":"Utverjdenie_tipa_s_pomoshchu_operatora_as"},{"name":"Приведение (утверждение) к константе (const assertion)","path":"Privedenie_(utverjdenie)_k_konstante_(const_assertion)"},{"name":"Утверждение в сигнатуре (Signature Assertion)","path":"Utverjdenie_v_signature_(Signature_Assertion)"}]},{"name":"Защитники типа","path":"Zashchitniki_tipa","sections":[{"name":"Защитники Типа - общее","path":"Zashchitniki_Tipa_-_obshchee"},{"name":"Сужение диапазона множества типов на основе типа данных","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_tipa_dannyh"},{"name":"Сужение диапазона множества типов на основе признаков присущих типу Tagged Union","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_priznakov_prisushchih_tipu_Tagged_Union"},{"name":"Сужение диапазона множества типов на основе доступных членов объекта","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_dostupnyh_chlenov_obekta"},{"name":"Сужение диапазона множества типов на основе функции, определенной пользователем","path":"Sujenie_diapazona_mnojestva_tipov_na_osnove_funkcii,opredelennoi_polzovatelem"}]},{"name":"Вывод типов","path":"Vyvod_tipov","sections":[{"name":"Вывод типов - общие сведения","path":"Vyvod_tipov_-_obshchie_svedeniya"},{"name":"Вывод примитивных типов","path":"Vyvod_primitivnyh_tipov"},{"name":"Вывод примитивных типов для констант (const) и полей только для чтения (readonly)","path":"Vyvod_primitivnyh_tipov_dlya_konstant_(const)_i_polei_tolko_dlya_chteniya_(readonly)"},{"name":"Вывод объектных типов","path":"Vyvod_obektnyh_tipov"},{"name":"Вывод типа для полей класса на основе инициализации их в конструкторе","path":"Vyvod_tipa_dlya_polei_klassa_na_osnove_inicializacii_ih_v_konstruktore"},{"name":"Вывод объединенных (Union) типов","path":"Vyvod_obedinennyh_(Union)_tipov"},{"name":"Вывод пересечения (Intersection) с дискриминантными полями","path":"Vyvod_peresecheniya_(Intersection)_s_diskriminantnymi_polyami"},{"name":"Вывод типов кортеж (Tuple)","path":"Vyvod_tipov_kortej_(Tuple)"}]},{"name":"Совместимость объектных типов (Compatible Object Types)","path":"Sovmestimost_obektnyh_tipov_(Compatible_Object_Types)","sections":[{"name":"Важно","path":"Vajno"},{"name":"Совместимость объектных типов в TypeScript","path":"Sovmestimost_obektnyh_tipov_v_TypeScript"}]},{"name":"Совместимость функциональных типов (Compatible Function Types)","path":"Sovmestimost_funkcionalnyh_tipov_(Compatible_Function_Types)","sections":[{"name":"Важно","path":"Vajno"},{"name":"Совместимость параметров","path":"Sovmestimost_parametrov"},{"name":"Совместимость возвращаемого значения","path":"Sovmestimost_vozvrashchaemogo_znacheniya"}]},{"name":"Совместимость объединений (Union Types)","path":"Sovmestimost_obedinenii_(Union_Types)","sections":[{"name":"Совместимость","path":"Sovmestimost"}]},{"name":"Типизация в TypeScript","path":"Tipizaciya_v_TypeScript","sections":[{"name":"Общие сведения","path":"Obshchie_svedeniya"},{"name":"Статическая типизация (static typing)","path":"Staticheskaya_tipizaciya_(static_typing)"},{"name":"Сильная типизация (strongly typed)","path":"Silnaya_tipizaciya_(strongly_typed)"},{"name":"Явно типизированный (explicit typing) с выводом типов (type inference)","path":"Yavno_tipizirovannyi_(explicit_typing)_s_vyvodom_tipov_(type_inference)"},{"name":"Совместимость типов (Type Compatibility), структурная типизация (structural typing)","path":"Sovmestimost_tipov_(Type_Compatibility),strukturnaya_tipizaciya_(structural_typing)"},{"name":"Вариантность (variance)","path":"Variantnost_(variance)"},{"name":"Наилучший общий тип (Best common type)","path":"Nailuchshii_obshchii_tip_(Best_common_type)"},{"name":"Контекстный тип (Contextual Type)","path":"Kontekstnyi_tip_(Contextual_Type)"}]},{"name":"Оператор keyof, Lookup Types, Mapped Types, Mapped Types - префиксы + и -","path":"Operator_keyof,Lookup_Types,Mapped_Types,Mapped_Types_-_prefiksy_+_i_-","sections":[{"name":"Запрос ключей keyof","path":"Zapros_kluchei_keyof"},{"name":"Поиск типов (Lookup Types)","path":"Poisk_tipov_(Lookup_Types)"},{"name":"Сопоставление типов (Mapped Types)","path":"Sopostavlenie_tipov_(Mapped_Types)"},{"name":"Префиксы + и - в сопоставленных типах","path":"Prefiksy_+_i_-_v_sopostavlennyh_tipah"}]},{"name":"Условные типы (Conditional Types)","path":"Uslovnye_tipy_(Conditional_Types)","sections":[{"name":"Условные типы на практике","path":"Uslovnye_tipy_na_praktike"},{"name":"Распределительные условные типы (Distributive Conditional Types)","path":"Raspredelitelnye_uslovnye_tipy_(Distributive_Conditional_Types)"},{"name":"Вывод типов в условном типе","path":"Vyvod_tipov_v_uslovnom_tipe"}]},{"name":"Readonly, Partial, Required, Pick, Record","path":"Readonly,Partial,Required,Pick,Record","sections":[{"name":"Readonly<T> (сделать члены объекта только для чтения)","path":"Readonly<T>_(sdelat_chleny_obekta_tolko_dlya_chteniya)"},{"name":"Partial<T> (сделать все члены объекта необязательными)","path":"Partial<T>_(sdelat_vse_chleny_obekta_neobyazatelnymi)"},{"name":"Required<T> (сделать все необязательные члены обязательными)","path":"Required<T>_(sdelat_vse_neobyazatelnye_chleny_obyazatelnymi)"},{"name":"Pick (отфильтровать объектный тип)","path":"Pick_(otfiltrovat_obektnyi_tip)"},{"name":"Record<K, T> (динамически определить поле в объектном типе)","path":"Record<K,T>_(dinamicheski_opredelit_pole_v_obektnom_tipe)"}]},{"name":"Exclude, Extract, NonNullable, ReturnType, InstanceType, Omit","path":"Exclude,Extract,NonNullable,ReturnType,InstanceType,Omit","sections":[{"name":"Exclude<T, U> (исключает из T признаки присущие U)","path":"Exclude<T,U>_(iskluchaet_iz_T_priznaki_prisushchie_U)"},{"name":"Extract<T, U> (общие для двух типов признаки)","path":"Extract<T,U>_(obshchie_dlya_dvuh_tipov_priznaki)"},{"name":"NonNullable<T> (удаляет типы null и undefined)","path":"NonNullable<T>_(udalyaet_tipy_null_i_undefined)"},{"name":"ReturnType<T> (получить тип значения возвращаемого функцией)","path":"ReturnType<T>_(poluchit_tip_znacheniya_vozvrashchaemogo_funkciei)"},{"name":"InstanceType<T> (получить через тип класса тип его экземпляра)","path":"InstanceType<T>_(poluchit_cherez_tip_klassa_tip_ego_ekzemplyara)"},{"name":"Parameters<T> (получить тип размеченного кортежа описывающий параметры функционального типа)","path":"Parameters<T>_(poluchit_tip_razmechennogo_korteja_opisyvaushchii_parametry_funkcionalnogo_tipa)"},{"name":"ConstructorParameters<T> (получить через тип класса размеченный кортеж описывающий параметры его конструктора)","path":"ConstructorParameters<T>_(poluchit_cherez_tip_klassa_razmechennyi_kortej_opisyvaushchii_parametry_ego_konstruktora)"},{"name":"Omit<T, K> (исключить из T признаки ассоциированными с ключами перечисленных множеством K)","path":"Omit<T,K>_(iskluchit_iz_T_priznaki_associirovannymi_s_kluchami_perechislennyh_mnojestvom_K)"}]},{"name":"Массивоподобные readonly типы, ReadonlyArray, ReadonlyMap, ReadonlySet","path":"Massivopodobnye_readonly_tipy,ReadonlyArray,ReadonlyMap,ReadonlySet","sections":[{"name":"Массивоподобные readonly типы (модифицировать непосредственно в аннотации типа)","path":"Massivopodobnye_readonly_tipy_(modificirovat_neposredstvenno_v_annotacii_tipa)"},{"name":"ReadonlyArray<T> (неизменяемый массив)","path":"ReadonlyArray<T>_(neizmenyaemyi_massiv)"},{"name":"ReadonlyMap<K, V> (неизменяемая карта)","path":"ReadonlyMap<K,V>_(neizmenyaemaya_karta)"},{"name":"ReadonlySet<T> (неизменяемое множество)","path":"ReadonlySet<T>_(neizmenyaemoe_mnojestvo)"}]},{"name":"Синтаксические конструкции и операторы","path":"Sintaksicheskie_konstrukcii_i_operatory","sections":[{"name":"Операторы присваивания короткого замыкания (&&=, ||=, &&=)","path":"Operatory_prisvaivaniya_korotkogo_zamykaniya_(&&=,||=,&&=)"},{"name":"Операнды для delete должны быть необязательными","path":"Operandy_dlya_delete_doljny_byt_neobyazatelnymi"},{"name":"Объявление переменных 'необязательными' при деструктуризации массивоподобных объектов","path":"Obyavlenie_peremennyh_'neobyazatelnymi'_pri_destrukturizacii_massivopodobnyh_obektov"},{"name":"Модификатор abstract для описания типа конструктора","path":"Modifikator_abstract_dlya_opisaniya_tipa_konstruktora"}]},{"name":"Типизированный React","path":"Tipizirovannyi_React","sections":[{"name":"Расширение .tsx","path":"Rasshirenie_.tsx"}]},{"name":"Функциональные компоненты","path":"Funkcionalnye_komponenty","sections":[{"name":"Определение компонента как Function Declaration","path":"Opredelenie_komponenta_kak_Function_Declaration"},{"name":"Определение компонента как Function Expression","path":"Opredelenie_komponenta_kak_Function_Expression"}]},{"name":"Классовые компоненты","path":"Klassovye_komponenty","sections":[{"name":"Производные от Component<P, S, SS>","path":"Proizvodnye_ot_Component<P,S,SS>"},{"name":"Производные от PureComponent<Props, State, Snapshot>","path":"Proizvodnye_ot_PureComponent<Props,State,Snapshot>"}]},{"name":"Универсальные компоненты","path":"Universalnye_komponenty","sections":[{"name":"Обобщенные компоненты (Generics Component)","path":"Obobshchennye_komponenty_(Generics_Component)"}]},{"name":"Типизированные хуки","path":"Tipizirovannye_huki","sections":[{"name":"Предопределенные хуки - useState<T>()","path":"Predopredelennye_huki_-_useState<T>()"},{"name":"Предопределенные хуки - useEffect() и useLayoutEffect()","path":"Predopredelennye_huki_-_useEffect()_i_useLayoutEffect()"},{"name":"Предопределенные хуки - useContext<T>()","path":"Predopredelennye_huki_-_useContext<T>()"},{"name":"Предопределенные хуки - useReducer<R>()","path":"Predopredelennye_huki_-_useReducer<R>()"},{"name":"Предопределенные хуки - useCallback<T>()","path":"Predopredelennye_huki_-_useCallback<T>()"},{"name":"Предопределенные хуки - useRef<T>()","path":"Predopredelennye_huki_-_useRef<T>()"},{"name":"Предопределенные хуки - useImperativeHandle<T, R>()","path":"Predopredelennye_huki_-_useImperativeHandle<T,R>()"},{"name":"Предопределенные хуки - useMemo<T>()","path":"Predopredelennye_huki_-_useMemo<T>()"},{"name":"Предопределенные хуки - useDebugValue<T>()","path":"Predopredelennye_huki_-_useDebugValue<T>()"},{"name":"Пользовательский хук","path":"Polzovatelskii_huk"}]},{"name":"Контекст (Context)","path":"Kontekst_(Context)","sections":[{"name":"Определение контекста","path":"Opredelenie_konteksta"}]},{"name":"HOC (Higher-Order Components)","path":"HOC_(Higher-Order_Components)","sections":[{"name":"Определение hoc","path":"Opredelenie_hoc"},{"name":"Определение hoc на основе функционального компонента","path":"Opredelenie_hoc_na_osnove_funkcionalnogo_komponenta"},{"name":"Определение hoc на основе классового компонента","path":"Opredelenie_hoc_na_osnove_klassovogo_komponenta"}]},{"name":"Пространства имен (namespace) и модули (module)","path":"Prostranstva_imen_(namespace)_i_moduli_(module)","sections":[{"name":"Namespace и module — предназначение","path":"Namespace_i_module_—_prednaznachenie"},{"name":"Namespace - определение","path":"Namespace_-_opredelenie"},{"name":"Модули (export, import) — определение","path":"Moduli_(export,import)_—_opredelenie"},{"name":"Конфигурирование проекта","path":"Konfigurirovanie_proekta"}]},{"name":"Настройка рабочего окружения","path":"Nastroika_rabochego_okrujeniya","sections":[{"name":"Настройка рабочего окружения","path":"Nastroika_rabochego_okrujeniya"},{"name":"Сборка проекта с помощью tsc (TypeScript compiler)","path":"Sborka_proekta_s_pomoshchu_tsc_(TypeScript_compiler)"}]},{"name":"Сборка с использованием ссылок на проекты","path":"Sborka_s_ispolzovaniem_ssylok_na_proekty","sections":[{"name":"Ссылки на проекты","path":"Ssylki_na_proekty"}]},{"name":"Декларации","path":"Deklaracii","sections":[{"name":"Что такое декларация (Declaration)","path":"Chto_takoe_deklaraciya_(Declaration)"},{"name":"Установка деклараций с помощью @types","path":"Ustanovka_deklaracii_s_pomoshchu_@types"},{"name":"Подготовка к созданию декларации","path":"Podgotovka_k_sozdaniu_deklaracii"},{"name":"Разновидности деклараций","path":"Raznovidnosti_deklaracii"},{"name":"Декларации и область видимости","path":"Deklaracii_i_oblast_vidimosti"},{"name":"Декларации для библиотек с одной точкой входа","path":"Deklaracii_dlya_bibliotek_s_odnoi_tochkoi_vhoda"},{"name":"Декларации для библиотек с множеством точек входа","path":"Deklaracii_dlya_bibliotek_s_mnojestvom_tochek_vhoda"},{"name":"Создание деклараций вручную","path":"Sozdanie_deklaracii_vruchnuu"},{"name":"Директива с тройным слешем (triple-slash directives)","path":"Direktiva_s_troinym_sleshem_(triple-slash_directives)"},{"name":"Импортирование декларации (import)","path":"Importirovanie_deklaracii_(import)"}]},{"name":"Публикация TypeScript","path":"Publikaciya_TypeScript","sections":[{"name":"Публикация","path":"Publikaciya"}]},{"name":"Опции компилятора","path":"Opcii_kompilyatora","sections":[{"name":"strict","path":"strict"},{"name":"suppressExcessPropertyErrors","path":"suppressExcessPropertyErrors"},{"name":"suppressImplicitAnyIndexErrors","path":"suppressImplicitAnyIndexErrors"},{"name":"noImplicitAny","path":"noImplicitAny"},{"name":"checkJs","path":"checkJs"},{"name":"JSX","path":"JSX"},{"name":"jsxFactory","path":"jsxFactory"},{"name":"target (t)","path":"target_(t)"},{"name":"extends","path":"extends"},{"name":"alwaysStrict","path":"alwaysStrict"},{"name":"strictNullChecks","path":"strictNullChecks"},{"name":"stripInternal","path":"stripInternal"},{"name":"noImplicitThis","path":"noImplicitThis"},{"name":"noImplicitUseStrict","path":"noImplicitUseStrict"},{"name":"baseUrl","path":"baseUrl"},{"name":"paths","path":"paths"},{"name":"rootDir","path":"rootDir"},{"name":"rootDirs","path":"rootDirs"},{"name":"traceResolution","path":"traceResolution"},{"name":"lib","path":"lib"},{"name":"noLib","path":"noLib"},{"name":"noResolve","path":"noResolve"},{"name":"noStrictGenericChecks","path":"noStrictGenericChecks"},{"name":"preserveConstEnums","path":"preserveConstEnums"},{"name":"removeComments","path":"removeComments"},{"name":"noUnusedLocals","path":"noUnusedLocals"},{"name":"noUnusedParameters","path":"noUnusedParameters"},{"name":"skipLibCheck","path":"skipLibCheck"},{"name":"declarationDir","path":"declarationDir"},{"name":"types","path":"types"},{"name":"typeRoots","path":"typeRoots"},{"name":"allowUnusedLabels","path":"allowUnusedLabels"},{"name":"noImplicitReturns","path":"noImplicitReturns"},{"name":"noFallthroughCasesInSwitch","path":"noFallthroughCasesInSwitch"},{"name":"outFile","path":"outFile"},{"name":"allowSyntheticDefaultImports","path":"allowSyntheticDefaultImports"},{"name":"allowUnreachableCode","path":"allowUnreachableCode"},{"name":"allowJs","path":"allowJs"},{"name":"reactNamespace","path":"reactNamespace"},{"name":"pretty","path":"pretty"},{"name":"moduleResolution","path":"moduleResolution"},{"name":"exclude","path":"exclude"},{"name":"noEmitHelpers","path":"noEmitHelpers"},{"name":"newLine","path":"newLine"},{"name":"inlineSourceMap","path":"inlineSourceMap"},{"name":"inlineSources","path":"inlineSources"},{"name":"noEmitOnError","path":"noEmitOnError"},{"name":"noEmit","path":"noEmit"},{"name":"charset","path":"charset"},{"name":"diagnostics","path":"diagnostics"},{"name":"declaration","path":"declaration"},{"name":"downlevelIteration","path":"downlevelIteration"},{"name":"emitBOM","path":"emitBOM"},{"name":"emitDecoratorMetadata","path":"emitDecoratorMetadata"},{"name":"forceConsistentCasingInFileNames","path":"forceConsistentCasingInFileNames"},{"name":"help (h)","path":"help_(h)"},{"name":"importHelpers","path":"importHelpers"},{"name":"isolatedModules","path":"isolatedModules"},{"name":"listEmittedFiles","path":"listEmittedFiles"},{"name":"listFiles","path":"listFiles"},{"name":"sourceRoot","path":"sourceRoot"},{"name":"mapRoot","path":"mapRoot"},{"name":"maxNodeModuleJsDepth","path":"maxNodeModuleJsDepth"},{"name":"project (p)","path":"project_(p)"},{"name":"init","path":"init"},{"name":"version (v)","path":"version_(v)"},{"name":"watch (w)","path":"watch_(w)"},{"name":"preserveSymlinks","path":"preserveSymlinks"},{"name":"strictFunctionTypes","path":"strictFunctionTypes"},{"name":"locale","path":"locale"},{"name":"strictPropertyInitialization","path":"strictPropertyInitialization"},{"name":"esModuleInterop","path":"esModuleInterop"},{"name":"emitDeclarationsOnly","path":"emitDeclarationsOnly"},{"name":"resolveJsonModule","path":"resolveJsonModule"},{"name":"declarationMap","path":"declarationMap"},{"name":"strictBindCallApply","path":"strictBindCallApply"},{"name":"showConfig","path":"showConfig"},{"name":"build","path":"build"},{"name":"verbose","path":"verbose"},{"name":"dry","path":"dry"},{"name":"clean","path":"clean"},{"name":"force","path":"force"},{"name":"incremental","path":"incremental"},{"name":"tsBuildInfoFile","path":"tsBuildInfoFile"},{"name":"allowUmdGlobalAccess","path":"allowUmdGlobalAccess"},{"name":"disableSourceOfProjectReferenceRedirect","path":"disableSourceOfProjectReferenceRedirect"},{"name":"useDefineForClassFields","path":"useDefineForClassFields"},{"name":"importsNotUsedAsValues","path":"importsNotUsedAsValues"},{"name":"assumeChangesOnlyAffectDirectDependencies","path":"assumeChangesOnlyAffectDirectDependencies"},{"name":"watchFile","path":"watchFile"},{"name":"watchDirectory","path":"watchDirectory"},{"name":"fallbackPolling","path":"fallbackPolling"},{"name":"synchronousWatchDirectory","path":"synchronousWatchDirectory"},{"name":"noUncheckedIndexedAccess","path":"noUncheckedIndexedAccess"},{"name":"noPropertyAccessFromIndexSignature","path":"noPropertyAccessFromIndexSignature"},{"name":"explainFiles","path":"explainFiles"}]}]}},"staticQueryHashes":["408059355","63159454"]}